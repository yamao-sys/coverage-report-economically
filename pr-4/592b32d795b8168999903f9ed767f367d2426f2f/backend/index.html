
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">app/db/db.go (14.3%)</option>
				
				<option value="file1">app/generated/auth/auth.go (0.0%)</option>
				
				<option value="file2">app/generated/todos/todos.go (0.0%)</option>
				
				<option value="file3">app/handlers/auth_handler.go (84.0%)</option>
				
				<option value="file4">app/handlers/main_handler.go (100.0%)</option>
				
				<option value="file5">app/handlers/todos_handler.go (69.9%)</option>
				
				<option value="file6">app/handlers/with_db_suite.go (89.3%)</option>
				
				<option value="file7">app/main.go (0.0%)</option>
				
				<option value="file8">app/middlewares/auth_middleware.go (90.0%)</option>
				
				<option value="file9">app/models/generated/boil_extra.go (0.0%)</option>
				
				<option value="file10">app/models/generated/boil_queries.go (100.0%)</option>
				
				<option value="file11">app/models/generated/boil_types.go (72.7%)</option>
				
				<option value="file12">app/models/generated/gorp_migrations.go (0.0%)</option>
				
				<option value="file13">app/models/generated/mysql_upsert.go (0.0%)</option>
				
				<option value="file14">app/models/generated/todos.go (24.8%)</option>
				
				<option value="file15">app/models/generated/users.go (16.1%)</option>
				
				<option value="file16">app/openapi/reference.go (69.2%)</option>
				
				<option value="file17">app/services/auth_service.go (83.3%)</option>
				
				<option value="file18">app/services/todo_service.go (87.8%)</option>
				
				<option value="file19">app/services/with_db_suite.go (85.7%)</option>
				
				<option value="file20">app/test/factories/users.go (75.0%)</option>
				
				<option value="file21">app/utils/ctxKey.go (100.0%)</option>
				
				<option value="file22">app/utils/routers/routers.go (100.0%)</option>
				
				<option value="file23">app/utils/validation.go (0.0%)</option>
				
				<option value="file24">app/validator/todo_validator.go (100.0%)</option>
				
				<option value="file25">app/validator/user_validator.go (81.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "database/sql"
        "log"
        "os"
)

func Init() *sql.DB <span class="cov0" title="0">{
        // DBインスタンス生成
        db, err := sql.Open("mysql", GetDsn())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">return db</span>
}

func Close(db *sql.DB) <span class="cov0" title="0">{
        if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func GetDsn() string <span class="cov8" title="1">{
        return os.Getenv("MYSQL_USER") +
                ":" + os.Getenv("MYSQL_PASS") +
                "@tcp(" + os.Getenv("MYSQL_HOST") + ":" + os.Getenv("MYSQL_PORT") + ")/" +
                os.Getenv("MYSQL_DBNAME") +
                "?charset=utf8mb4&amp;collation=utf8mb4_general_ci&amp;parseTime=true&amp;loc=Local"
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package auth provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "mime/multipart"
        "net/http"

        "github.com/labstack/echo/v4"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

// SignUpValidationError defines model for SignUpValidationError.
type SignUpValidationError struct {
        BackIdentification  *[]string `json:"backIdentification,omitempty"`
        Birthday            *[]string `json:"birthday,omitempty"`
        Email               *[]string `json:"email,omitempty"`
        FirstName           *[]string `json:"firstName,omitempty"`
        FrontIdentification *[]string `json:"frontIdentification,omitempty"`
        LastName            *[]string `json:"lastName,omitempty"`
        Password            *[]string `json:"password,omitempty"`
}

// CsrfResponse defines model for CsrfResponse.
type CsrfResponse struct {
        CsrfToken string `json:"csrf_token"`
}

// InternalServerErrorResponse defines model for InternalServerErrorResponse.
type InternalServerErrorResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

// SignInBadRequestResponse defines model for SignInBadRequestResponse.
type SignInBadRequestResponse struct {
        Errors []string `json:"errors"`
}

// SignInOkResponse defines model for SignInOkResponse.
type SignInOkResponse = map[string]interface{}

// SignUpResponse defines model for SignUpResponse.
type SignUpResponse struct {
        Code   int64                 `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

// SignInInput defines model for SignInInput.
type SignInInput struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// PostAuthSignInJSONBody defines parameters for PostAuthSignIn.
type PostAuthSignInJSONBody struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// PostAuthSignUpMultipartBody defines parameters for PostAuthSignUp.
type PostAuthSignUpMultipartBody struct {
        BackIdentification  *openapi_types.File `json:"backIdentification,omitempty"`
        Birthday            *openapi_types.Date `json:"birthday,omitempty"`
        Email               string              `json:"email"`
        FirstName           string              `json:"firstName"`
        FrontIdentification *openapi_types.File `json:"frontIdentification,omitempty"`
        LastName            string              `json:"lastName"`
        Password            string              `json:"password"`
}

// PostAuthValidateSignUpMultipartBody defines parameters for PostAuthValidateSignUp.
type PostAuthValidateSignUpMultipartBody struct {
        BackIdentification  *openapi_types.File `json:"backIdentification,omitempty"`
        Birthday            *openapi_types.Date `json:"birthday,omitempty"`
        Email               string              `json:"email"`
        FirstName           string              `json:"firstName"`
        FrontIdentification *openapi_types.File `json:"frontIdentification,omitempty"`
        LastName            string              `json:"lastName"`
        Password            string              `json:"password"`
}

// PostAuthSignInJSONRequestBody defines body for PostAuthSignIn for application/json ContentType.
type PostAuthSignInJSONRequestBody PostAuthSignInJSONBody

// PostAuthSignUpMultipartRequestBody defines body for PostAuthSignUp for multipart/form-data ContentType.
type PostAuthSignUpMultipartRequestBody PostAuthSignUpMultipartBody

// PostAuthValidateSignUpMultipartRequestBody defines body for PostAuthValidateSignUp for multipart/form-data ContentType.
type PostAuthValidateSignUpMultipartRequestBody PostAuthValidateSignUpMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Get Csrf
        // (GET /auth/csrf)
        GetAuthCsrf(ctx echo.Context) error
        // Sign In
        // (POST /auth/signIn)
        PostAuthSignIn(ctx echo.Context) error
        // SignUp
        // (POST /auth/signUp)
        PostAuthSignUp(ctx echo.Context) error
        // Validate SignUp
        // (POST /auth/validateSignUp)
        PostAuthValidateSignUp(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// GetAuthCsrf converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthCsrf(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetAuthCsrf(ctx)
        return err
}</span>

// PostAuthSignIn converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSignIn(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostAuthSignIn(ctx)
        return err
}</span>

// PostAuthSignUp converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSignUp(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostAuthSignUp(ctx)
        return err
}</span>

// PostAuthValidateSignUp converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthValidateSignUp(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostAuthValidateSignUp(ctx)
        return err
}</span>

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/auth/csrf", wrapper.GetAuthCsrf)
        router.POST(baseURL+"/auth/signIn", wrapper.PostAuthSignIn)
        router.POST(baseURL+"/auth/signUp", wrapper.PostAuthSignUp)
        router.POST(baseURL+"/auth/validateSignUp", wrapper.PostAuthValidateSignUp)

}</span>

type CsrfResponseJSONResponse struct {
        CsrfToken string `json:"csrf_token"`
}

type InternalServerErrorResponseJSONResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

type SignInBadRequestResponseJSONResponse struct {
        Errors []string `json:"errors"`
}

type SignInOkResponseResponseHeaders struct {
        SetCookie string
}
type SignInOkResponseJSONResponse struct {
        Body map[string]interface{}

        Headers SignInOkResponseResponseHeaders
}

type SignUpResponseJSONResponse struct {
        Code   int64                 `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

type GetAuthCsrfRequestObject struct {
}

type GetAuthCsrfResponseObject interface {
        VisitGetAuthCsrfResponse(w http.ResponseWriter) error
}

type GetAuthCsrf200JSONResponse struct{ CsrfResponseJSONResponse }

func (response GetAuthCsrf200JSONResponse) VisitGetAuthCsrfResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetAuthCsrf500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response GetAuthCsrf500JSONResponse) VisitGetAuthCsrfResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignInRequestObject struct {
        Body *PostAuthSignInJSONRequestBody
}

type PostAuthSignInResponseObject interface {
        VisitPostAuthSignInResponse(w http.ResponseWriter) error
}

type PostAuthSignIn200JSONResponse struct{ SignInOkResponseJSONResponse }

func (response PostAuthSignIn200JSONResponse) VisitPostAuthSignInResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PostAuthSignIn400JSONResponse struct {
        SignInBadRequestResponseJSONResponse
}

func (response PostAuthSignIn400JSONResponse) VisitPostAuthSignInResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignIn500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostAuthSignIn500JSONResponse) VisitPostAuthSignInResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignUpRequestObject struct {
        Body *multipart.Reader
}

type PostAuthSignUpResponseObject interface {
        VisitPostAuthSignUpResponse(w http.ResponseWriter) error
}

type PostAuthSignUp200JSONResponse struct{ SignUpResponseJSONResponse }

func (response PostAuthSignUp200JSONResponse) VisitPostAuthSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignUp400JSONResponse struct {
        Code   int64                 `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

func (response PostAuthSignUp400JSONResponse) VisitPostAuthSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignUp500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostAuthSignUp500JSONResponse) VisitPostAuthSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthValidateSignUpRequestObject struct {
        Body *multipart.Reader
}

type PostAuthValidateSignUpResponseObject interface {
        VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error
}

type PostAuthValidateSignUp200JSONResponse struct{ SignUpResponseJSONResponse }

func (response PostAuthValidateSignUp200JSONResponse) VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthValidateSignUp400JSONResponse struct {
        Code   int64                 `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

func (response PostAuthValidateSignUp400JSONResponse) VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthValidateSignUp500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostAuthValidateSignUp500JSONResponse) VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Get Csrf
        // (GET /auth/csrf)
        GetAuthCsrf(ctx context.Context, request GetAuthCsrfRequestObject) (GetAuthCsrfResponseObject, error)
        // Sign In
        // (POST /auth/signIn)
        PostAuthSignIn(ctx context.Context, request PostAuthSignInRequestObject) (PostAuthSignInResponseObject, error)
        // SignUp
        // (POST /auth/signUp)
        PostAuthSignUp(ctx context.Context, request PostAuthSignUpRequestObject) (PostAuthSignUpResponseObject, error)
        // Validate SignUp
        // (POST /auth/validateSignUp)
        PostAuthValidateSignUp(ctx context.Context, request PostAuthValidateSignUpRequestObject) (PostAuthValidateSignUpResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// GetAuthCsrf operation middleware
func (sh *strictHandler) GetAuthCsrf(ctx echo.Context) error <span class="cov0" title="0">{
        var request GetAuthCsrfRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetAuthCsrf(ctx.Request().Context(), request.(GetAuthCsrfRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetAuthCsrf")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetAuthCsrfResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetAuthCsrfResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostAuthSignIn operation middleware
func (sh *strictHandler) PostAuthSignIn(ctx echo.Context) error <span class="cov0" title="0">{
        var request PostAuthSignInRequestObject

        var body PostAuthSignInJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PostAuthSignIn(ctx.Request().Context(), request.(PostAuthSignInRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PostAuthSignIn")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PostAuthSignInResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitPostAuthSignInResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostAuthSignUp operation middleware
func (sh *strictHandler) PostAuthSignUp(ctx echo.Context) error <span class="cov0" title="0">{
        var request PostAuthSignUpRequestObject

        if reader, err := ctx.Request().MultipartReader(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> {
                request.Body = reader
        }</span>

        <span class="cov0" title="0">handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PostAuthSignUp(ctx.Request().Context(), request.(PostAuthSignUpRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PostAuthSignUp")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PostAuthSignUpResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitPostAuthSignUpResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostAuthValidateSignUp operation middleware
func (sh *strictHandler) PostAuthValidateSignUp(ctx echo.Context) error <span class="cov0" title="0">{
        var request PostAuthValidateSignUpRequestObject

        if reader, err := ctx.Request().MultipartReader(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> {
                request.Body = reader
        }</span>

        <span class="cov0" title="0">handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PostAuthValidateSignUp(ctx.Request().Context(), request.(PostAuthValidateSignUpRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PostAuthValidateSignUp")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PostAuthValidateSignUpResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitPostAuthValidateSignUpResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package todos provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package todos

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
)

const (
        CookieAuthScopes = "cookieAuth.Scopes"
)

// StoreTodoValidationError defines model for StoreTodoValidationError.
type StoreTodoValidationError struct {
        Content *[]string `json:"content,omitempty"`
        Title   *[]string `json:"title,omitempty"`
}

// Todo defines model for Todo.
type Todo struct {
        Content string `json:"content"`
        Id      int    `json:"id"`
        Title   string `json:"title"`
}

// DeleteTodoResponse defines model for DeleteTodoResponse.
type DeleteTodoResponse struct {
        Code   int64 `json:"code"`
        Result bool  `json:"result"`
}

// FetchTodosResponse defines model for FetchTodosResponse.
type FetchTodosResponse struct {
        Todos []Todo `json:"todos"`
}

// InternalServerErrorResponse defines model for InternalServerErrorResponse.
type InternalServerErrorResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

// NotFoundErrorResponse defines model for NotFoundErrorResponse.
type NotFoundErrorResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

// ShowTodoResponse defines model for ShowTodoResponse.
type ShowTodoResponse struct {
        Todo Todo `json:"todo"`
}

// StoreTodoResponse defines model for StoreTodoResponse.
type StoreTodoResponse struct {
        Code   int64                    `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

// UnauthorizedErrorResponse defines model for UnauthorizedErrorResponse.
type UnauthorizedErrorResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

// StoreTodoInput defines model for StoreTodoInput.
type StoreTodoInput struct {
        Content string `json:"content"`
        Title   string `json:"title"`
}

// PostTodosJSONBody defines parameters for PostTodos.
type PostTodosJSONBody struct {
        Content string `json:"content"`
        Title   string `json:"title"`
}

// PatchTodoJSONBody defines parameters for PatchTodo.
type PatchTodoJSONBody struct {
        Content string `json:"content"`
        Title   string `json:"title"`
}

// PostTodosJSONRequestBody defines body for PostTodos for application/json ContentType.
type PostTodosJSONRequestBody PostTodosJSONBody

// PatchTodoJSONRequestBody defines body for PatchTodo for application/json ContentType.
type PatchTodoJSONRequestBody PatchTodoJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Fetch Todos
        // (GET /todos)
        GetTodos(ctx echo.Context) error
        // Create Todo
        // (POST /todos)
        PostTodos(ctx echo.Context) error
        // Delete Todo
        // (DELETE /todos/{id})
        DeleteTodo(ctx echo.Context, id string) error
        // Show Todo
        // (GET /todos/{id})
        GetTodo(ctx echo.Context, id string) error
        // Update Todo
        // (PATCH /todos/{id})
        PatchTodo(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// GetTodos converts echo context to params.
func (w *ServerInterfaceWrapper) GetTodos(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetTodos(ctx)
        return err
}</span>

// PostTodos converts echo context to params.
func (w *ServerInterfaceWrapper) PostTodos(ctx echo.Context) error <span class="cov0" title="0">{
        var err error

        ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostTodos(ctx)
        return err
}</span>

// DeleteTodo converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTodo(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteTodo(ctx, id)
        return err</span>
}

// GetTodo converts echo context to params.
func (w *ServerInterfaceWrapper) GetTodo(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetTodo(ctx, id)
        return err</span>
}

// PatchTodo converts echo context to params.
func (w *ServerInterfaceWrapper) PatchTodo(ctx echo.Context) error <span class="cov0" title="0">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov0" title="0">ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PatchTodo(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov0" title="0">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov0" title="0">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/todos", wrapper.GetTodos)
        router.POST(baseURL+"/todos", wrapper.PostTodos)
        router.DELETE(baseURL+"/todos/:id", wrapper.DeleteTodo)
        router.GET(baseURL+"/todos/:id", wrapper.GetTodo)
        router.PATCH(baseURL+"/todos/:id", wrapper.PatchTodo)

}</span>

type DeleteTodoResponseJSONResponse struct {
        Code   int64 `json:"code"`
        Result bool  `json:"result"`
}

type FetchTodosResponseJSONResponse struct {
        Todos []Todo `json:"todos"`
}

type InternalServerErrorResponseJSONResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

type NotFoundErrorResponseJSONResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

type ShowTodoResponseJSONResponse struct {
        Todo Todo `json:"todo"`
}

type StoreTodoResponseJSONResponse struct {
        Code   int64                    `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

type UnauthorizedErrorResponseJSONResponse struct {
        Code    int64  `json:"code"`
        Message string `json:"message"`
}

type GetTodosRequestObject struct {
}

type GetTodosResponseObject interface {
        VisitGetTodosResponse(w http.ResponseWriter) error
}

type GetTodos200JSONResponse struct{ FetchTodosResponseJSONResponse }

func (response GetTodos200JSONResponse) VisitGetTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodos401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response GetTodos401JSONResponse) VisitGetTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodos500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response GetTodos500JSONResponse) VisitGetTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodosRequestObject struct {
        Body *PostTodosJSONRequestBody
}

type PostTodosResponseObject interface {
        VisitPostTodosResponse(w http.ResponseWriter) error
}

type PostTodos200JSONResponse struct{ StoreTodoResponseJSONResponse }

func (response PostTodos200JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodos400JSONResponse struct {
        Code   int64                    `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

func (response PostTodos400JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodos401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response PostTodos401JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodos500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostTodos500JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodoRequestObject struct {
        Id string `json:"id"`
}

type DeleteTodoResponseObject interface {
        VisitDeleteTodoResponse(w http.ResponseWriter) error
}

type DeleteTodo200JSONResponse struct{ DeleteTodoResponseJSONResponse }

func (response DeleteTodo200JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodo401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response DeleteTodo401JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodo404JSONResponse struct {
        NotFoundErrorResponseJSONResponse
}

func (response DeleteTodo404JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodo500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response DeleteTodo500JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodoRequestObject struct {
        Id string `json:"id"`
}

type GetTodoResponseObject interface {
        VisitGetTodoResponse(w http.ResponseWriter) error
}

type GetTodo200JSONResponse struct{ ShowTodoResponseJSONResponse }

func (response GetTodo200JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodo401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response GetTodo401JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodo404JSONResponse struct {
        NotFoundErrorResponseJSONResponse
}

func (response GetTodo404JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodo500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response GetTodo500JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodoRequestObject struct {
        Id   string `json:"id"`
        Body *PatchTodoJSONRequestBody
}

type PatchTodoResponseObject interface {
        VisitPatchTodoResponse(w http.ResponseWriter) error
}

type PatchTodo200JSONResponse struct{ StoreTodoResponseJSONResponse }

func (response PatchTodo200JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo400JSONResponse struct {
        Code   int64                    `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

func (response PatchTodo400JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response PatchTodo401JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo404JSONResponse struct {
        NotFoundErrorResponseJSONResponse
}

func (response PatchTodo404JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PatchTodo500JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Fetch Todos
        // (GET /todos)
        GetTodos(ctx context.Context, request GetTodosRequestObject) (GetTodosResponseObject, error)
        // Create Todo
        // (POST /todos)
        PostTodos(ctx context.Context, request PostTodosRequestObject) (PostTodosResponseObject, error)
        // Delete Todo
        // (DELETE /todos/{id})
        DeleteTodo(ctx context.Context, request DeleteTodoRequestObject) (DeleteTodoResponseObject, error)
        // Show Todo
        // (GET /todos/{id})
        GetTodo(ctx context.Context, request GetTodoRequestObject) (GetTodoResponseObject, error)
        // Update Todo
        // (PATCH /todos/{id})
        PatchTodo(ctx context.Context, request PatchTodoRequestObject) (PatchTodoResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// GetTodos operation middleware
func (sh *strictHandler) GetTodos(ctx echo.Context) error <span class="cov0" title="0">{
        var request GetTodosRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetTodos(ctx.Request().Context(), request.(GetTodosRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetTodos")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetTodosResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetTodosResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostTodos operation middleware
func (sh *strictHandler) PostTodos(ctx echo.Context) error <span class="cov0" title="0">{
        var request PostTodosRequestObject

        var body PostTodosJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PostTodos(ctx.Request().Context(), request.(PostTodosRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PostTodos")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PostTodosResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitPostTodosResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteTodo operation middleware
func (sh *strictHandler) DeleteTodo(ctx echo.Context, id string) error <span class="cov0" title="0">{
        var request DeleteTodoRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteTodo(ctx.Request().Context(), request.(DeleteTodoRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteTodo")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteTodoResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitDeleteTodoResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTodo operation middleware
func (sh *strictHandler) GetTodo(ctx echo.Context, id string) error <span class="cov0" title="0">{
        var request GetTodoRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetTodo(ctx.Request().Context(), request.(GetTodoRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetTodo")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetTodoResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitGetTodoResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PatchTodo operation middleware
func (sh *strictHandler) PatchTodo(ctx echo.Context, id string) error <span class="cov0" title="0">{
        var request PatchTodoRequestObject

        request.Id = id

        var body PatchTodoJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PatchTodo(ctx.Request().Context(), request.(PatchTodoRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PatchTodo")
        }</span>

        <span class="cov0" title="0">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PatchTodoResponseObject); ok </span><span class="cov0" title="0">{
                return validResponse.VisitPatchTodoResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        apis "app/openapi"
        "app/services"
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "mime/multipart"
        "net/http"
        "time"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/labstack/echo/v4/middleware"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

type AuthHandler interface {
        GetAuthCsrf(ctx context.Context, request apis.GetAuthCsrfRequestObject) (apis.GetAuthCsrfResponseObject, error)
        PostAuthSignIn(ctx context.Context, request apis.PostAuthSignInRequestObject) (apis.PostAuthSignInResponseObject, error)
        PostAuthValidateSignUp(ctx context.Context, request apis.PostAuthValidateSignUpRequestObject) (apis.PostAuthValidateSignUpResponseObject, error)
        PostAuthSignUp(ctx context.Context, request apis.PostAuthSignUpRequestObject) (apis.PostAuthSignUpResponseObject, error)
}

type authHandler struct {
        authService services.AuthService
}

func NewAuthHandler(authService services.AuthService) AuthHandler <span class="cov8" title="1">{
        return &amp;authHandler{authService}
}</span>

func (authHandler *authHandler) GetAuthCsrf(ctx context.Context, request apis.GetAuthCsrfRequestObject) (apis.GetAuthCsrfResponseObject, error) <span class="cov8" title="1">{
        csrfToken, ok := ctx.Value(middleware.DefaultCSRFConfig.ContextKey).(string)
        if !ok </span><span class="cov0" title="0">{
                return apis.GetAuthCsrf500JSONResponse{InternalServerErrorResponseJSONResponse: apis.InternalServerErrorResponseJSONResponse{
                        Code: http.StatusInternalServerError,
                        Message: "failed to retrieval token",
                }}, nil
        }</span>
        
        <span class="cov8" title="1">return apis.GetAuthCsrf200JSONResponse{CsrfResponseJSONResponse: apis.CsrfResponseJSONResponse{ CsrfToken: csrfToken }}, nil</span>
}

func (authHandler *authHandler) PostAuthSignIn(ctx context.Context, request apis.PostAuthSignInRequestObject) (apis.PostAuthSignInResponseObject, error) <span class="cov8" title="1">{
        inputs := apis.PostAuthSignInJSONBody{
                Email: request.Body.Email,
                Password: request.Body.Password,
        }

        statusCode, tokenString, err := authHandler.authService.SignIn(ctx, inputs)
        switch (statusCode) </span>{
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return apis.PostAuthSignIn500JSONResponse{InternalServerErrorResponseJSONResponse: apis.InternalServerErrorResponseJSONResponse{
                        Code: http.StatusInternalServerError,
                        Message: err.Error(),
                }}, nil</span>
        case http.StatusBadRequest:<span class="cov8" title="1">
                return apis.PostAuthSignIn400JSONResponse{SignInBadRequestResponseJSONResponse: apis.SignInBadRequestResponseJSONResponse{
                        Errors: []string{err.Error()},
                }}, nil</span>
        }
        
        // NOTE: Cookieにtokenをセット
        <span class="cov8" title="1">cookie := &amp;http.Cookie{
                Name:     "token",
                Value:    tokenString,
                MaxAge:   3600 * 24,
                Path:     "/",
                Domain:   "localhost",
                Secure:   false,
                HttpOnly: true,
        }
        return apis.PostAuthSignIn200JSONResponse{SignInOkResponseJSONResponse: apis.SignInOkResponseJSONResponse{
                Headers: apis.SignInOkResponseResponseHeaders{
                        SetCookie: cookie.String(),
                },
        }}, nil</span>
}

func (authHandler *authHandler) PostAuthValidateSignUp(ctx context.Context, request apis.PostAuthValidateSignUpRequestObject) (apis.PostAuthValidateSignUpResponseObject, error) <span class="cov8" title="1">{
        reader := request.Body
        // NOTE: バリデーションチェックを行う構造体
        inputStruct, mappingErr := authHandler.mappingInputStruct(reader)
        if mappingErr != nil </span><span class="cov0" title="0">{
                return apis.PostAuthValidateSignUp500JSONResponse{InternalServerErrorResponseJSONResponse: apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError, Message: mappingErr.Error()}}, nil
        }</span>

        <span class="cov8" title="1">err := authHandler.authService.ValidateSignUp(ctx, &amp;inputStruct)
        validationError := authHandler.mappingValidationErrorStruct(err)

        res := &amp;apis.SignUpResponse{
                Code: http.StatusOK,
                Errors: validationError,
        }
        return apis.PostAuthValidateSignUp200JSONResponse{SignUpResponseJSONResponse: apis.SignUpResponseJSONResponse{Code: res.Code, Errors: res.Errors}}, nil</span>
}

func (authHandler *authHandler) PostAuthSignUp(ctx context.Context, request apis.PostAuthSignUpRequestObject) (apis.PostAuthSignUpResponseObject, error) <span class="cov8" title="1">{
        reader := request.Body
        // NOTE: バリデーションチェックを行う構造体
        inputStruct, mappingErr := authHandler.mappingInputStruct(reader)
        if mappingErr != nil </span><span class="cov0" title="0">{
                return apis.PostAuthSignUp500JSONResponse{InternalServerErrorResponseJSONResponse: apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError, Message: mappingErr.Error()}}, nil
        }</span>

        <span class="cov8" title="1">err := authHandler.authService.ValidateSignUp(ctx, &amp;inputStruct)
        if err != nil </span><span class="cov0" title="0">{
                validationError := authHandler.mappingValidationErrorStruct(err)
        
                res := &amp;apis.SignUpResponse{
                        Code: http.StatusBadRequest,
                        Errors: validationError,
                }
                return apis.PostAuthSignUp400JSONResponse{Code: res.Code, Errors: res.Errors}, nil
        }</span>

        <span class="cov8" title="1">signUpErr := authHandler.authService.SignUp(ctx, apis.PostAuthSignUpMultipartRequestBody(inputStruct))
        if signUpErr != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov8" title="1">res := &amp;apis.SignUpResponse{
                Code: http.StatusOK,
                Errors: apis.SignUpValidationError{},
        }
        return apis.PostAuthSignUp200JSONResponse{SignUpResponseJSONResponse: apis.SignUpResponseJSONResponse{Code: res.Code, Errors: res.Errors}}, nil</span>
}

func (authHandler *authHandler) mappingInputStruct(reader *multipart.Reader) (apis.PostAuthValidateSignUpMultipartRequestBody, error) <span class="cov8" title="1">{
        var inputStruct apis.PostAuthValidateSignUpMultipartRequestBody

        for </span><span class="cov8" title="1">{
                part, err := reader.NextPart()
                if err == io.EOF </span><span class="cov8" title="1">{
                        // NOTE: 全てのパートを読み終えた場合
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return inputStruct, fmt.Errorf("failed to read multipart part: %w", err)
                }</span>

                // NOTE: 各パートのヘッダー情報を取得
                <span class="cov8" title="1">partName := part.FormName()
                filename := part.FileName()

                var buf bytes.Buffer
                if _, err := io.Copy(&amp;buf, part); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return inputStruct, fmt.Errorf("failed to copy content: %w", err)
                }</span>

                <span class="cov8" title="1">switch partName </span>{
                case "firstName":<span class="cov8" title="1">
                        inputStruct.FirstName = buf.String()</span>
                case "lastName":<span class="cov8" title="1">
                        inputStruct.LastName = buf.String()</span>
                case "password":<span class="cov8" title="1">
                        inputStruct.Password = buf.String()</span>
                case "email":<span class="cov8" title="1">
                        inputStruct.Email = buf.String()</span>
                case "birthday":<span class="cov8" title="1">
                        birthday := buf.String()
                        if birthday == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        
                        <span class="cov8" title="1">parsedTime, parseErr := time.Parse("2006-01-02", birthday)
                        if parseErr != nil </span><span class="cov0" title="0">{
                                fmt.Println(parseErr)
                                return inputStruct, fmt.Errorf("failed to parse birthday: %w", parseErr)
                        }</span>
                        <span class="cov8" title="1">inputStruct.Birthday = &amp;openapi_types.Date{Time: parsedTime}</span>
                case "frontIdentification":<span class="cov8" title="1">
                        var frontIdentification openapi_types.File
                        frontIdentification.InitFromBytes(buf.Bytes(), filename)
                        inputStruct.FrontIdentification = &amp;frontIdentification</span>
                case "backIdentification":<span class="cov8" title="1">
                        var backIdentification openapi_types.File
                        backIdentification.InitFromBytes(buf.Bytes(), filename)
                        inputStruct.BackIdentification = &amp;backIdentification</span>
                }
        }

        <span class="cov8" title="1">return inputStruct, nil</span>
}

func (authHandler *authHandler) mappingValidationErrorStruct(err error) apis.SignUpValidationError <span class="cov8" title="1">{
        var validationError apis.SignUpValidationError
        if err == nil </span><span class="cov8" title="1">{
                return validationError
        }</span>

        <span class="cov8" title="1">if errors, ok := err.(validation.Errors); ok </span><span class="cov8" title="1">{
                // NOTE: レスポンス用の構造体にマッピング
                for field, err := range errors </span><span class="cov8" title="1">{
                        messages := []string{err.Error()}
                        switch field </span>{
                        case "firstName":<span class="cov8" title="1">
                                validationError.FirstName = &amp;messages</span>
                        case "lastName":<span class="cov8" title="1">
                                validationError.LastName = &amp;messages</span>
                        case "email":<span class="cov8" title="1">
                                validationError.Email = &amp;messages</span>
                        case "password":<span class="cov8" title="1">
                                validationError.Password = &amp;messages</span>
                        case "frontIdentification":<span class="cov8" title="1">
                                validationError.FrontIdentification = &amp;messages</span>
                        case "backIdentification":<span class="cov8" title="1">
                                validationError.BackIdentification = &amp;messages</span>
                        }
                }
        }
        <span class="cov8" title="1">return validationError</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        apis "app/openapi"
        "context"
)

type MainHandler interface {
        // handlers /auth
        GetAuthCsrf(ctx context.Context, request apis.GetAuthCsrfRequestObject) (apis.GetAuthCsrfResponseObject, error)
        PostAuthSignIn(ctx context.Context, request apis.PostAuthSignInRequestObject) (apis.PostAuthSignInResponseObject, error)
        PostAuthValidateSignUp(ctx context.Context, request apis.PostAuthValidateSignUpRequestObject) (apis.PostAuthValidateSignUpResponseObject, error)
        PostAuthSignUp(ctx context.Context, request apis.PostAuthSignUpRequestObject) (apis.PostAuthSignUpResponseObject, error)

        // handlers /todos
        GetTodos(ctx context.Context, request apis.GetTodosRequestObject) (apis.GetTodosResponseObject, error)
        PostTodos(ctx context.Context, request apis.PostTodosRequestObject) (apis.PostTodosResponseObject, error)
        GetTodo(ctx context.Context, request apis.GetTodoRequestObject) (apis.GetTodoResponseObject, error)
        PatchTodo(ctx context.Context, request apis.PatchTodoRequestObject) (apis.PatchTodoResponseObject, error)
        DeleteTodo(ctx context.Context, request apis.DeleteTodoRequestObject) (apis.DeleteTodoResponseObject, error)
}

type mainHandler struct {
        authHandler AuthHandler
        todosHandler TodosHandler
}

func NewMainHandler(authHandler AuthHandler, todosHandler TodosHandler) MainHandler <span class="cov8" title="1">{
        return &amp;mainHandler{authHandler: authHandler, todosHandler: todosHandler}
}</span>

func (mh *mainHandler) GetAuthCsrf(ctx context.Context, request apis.GetAuthCsrfRequestObject) (apis.GetAuthCsrfResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.authHandler.GetAuthCsrf(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) PostAuthSignIn(ctx context.Context, request apis.PostAuthSignInRequestObject) (apis.PostAuthSignInResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.authHandler.PostAuthSignIn(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) PostAuthValidateSignUp(ctx context.Context, request apis.PostAuthValidateSignUpRequestObject) (apis.PostAuthValidateSignUpResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.authHandler.PostAuthValidateSignUp(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) PostAuthSignUp(ctx context.Context, request apis.PostAuthSignUpRequestObject) (apis.PostAuthSignUpResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.authHandler.PostAuthSignUp(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) GetTodos(ctx context.Context, request apis.GetTodosRequestObject) (apis.GetTodosResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.todosHandler.GetTodos(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) PostTodos(ctx context.Context, request apis.PostTodosRequestObject) (apis.PostTodosResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.todosHandler.PostTodos(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) GetTodo(ctx context.Context, request apis.GetTodoRequestObject) (apis.GetTodoResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.todosHandler.GetTodo(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) PatchTodo(ctx context.Context, request apis.PatchTodoRequestObject) (apis.PatchTodoResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.todosHandler.PatchTodo(ctx, request)
        return res, err
}</span>

func (mh *mainHandler) DeleteTodo(ctx context.Context, request apis.DeleteTodoRequestObject) (apis.DeleteTodoResponseObject, error) <span class="cov8" title="1">{
        res, err := mh.todosHandler.DeleteTodo(ctx, request)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        apis "app/openapi"
        "app/services"
        "app/utils"
        "context"
        "errors"
        "net/http"
        "strconv"

        validation "github.com/go-ozzo/ozzo-validation/v4"
)

type TodosHandler interface {
        GetTodos(ctx context.Context, request apis.GetTodosRequestObject) (apis.GetTodosResponseObject, error)
        PostTodos(ctx context.Context, request apis.PostTodosRequestObject) (apis.PostTodosResponseObject, error)
        GetTodo(ctx context.Context, request apis.GetTodoRequestObject) (apis.GetTodoResponseObject, error)
        PatchTodo(ctx context.Context, request apis.PatchTodoRequestObject) (apis.PatchTodoResponseObject, error)
        DeleteTodo(ctx context.Context, request apis.DeleteTodoRequestObject) (apis.DeleteTodoResponseObject, error)
}

type todosHandler struct {
        todoService services.TodoService
}

func NewTodosHandler(todoService services.TodoService) TodosHandler <span class="cov8" title="1">{
        return &amp;todosHandler{todoService: todoService}
}</span>

func (todosHandler *todosHandler) GetTodos(ctx context.Context, request apis.GetTodosRequestObject) (apis.GetTodosResponseObject, error) <span class="cov8" title="1">{
        userID, ok := utils.ContextValue(ctx)
        if !ok </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.GetTodos500JSONResponse{InternalServerErrorResponseJSONResponse: res}, errors.New("fail to load context value")
        }</span>

        <span class="cov8" title="1">statusCode, todosList, err := todosHandler.todoService.FetchTodosList(ctx, userID)
        switch statusCode </span>{
        case http.StatusInternalServerError:<span class="cov0" title="0">
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError, Message: err.Error()}
                return apis.GetTodos500JSONResponse{InternalServerErrorResponseJSONResponse: res}, err</span>
        }

        <span class="cov8" title="1">var resTodosList apis.FetchTodosResponseJSONResponse
        for _, todo := range *todosList </span><span class="cov8" title="1">{
                resTodosList.Todos = append(resTodosList.Todos, apis.Todo{Id: int(todo.ID), Title: todo.Title, Content: todo.Content.String })
        }</span>
        <span class="cov8" title="1">return apis.GetTodos200JSONResponse{FetchTodosResponseJSONResponse: resTodosList}, nil</span>
}

func (todosHandler *todosHandler) PostTodos(ctx context.Context, request apis.PostTodosRequestObject) (apis.PostTodosResponseObject, error) <span class="cov8" title="1">{
        userID, ok := utils.ContextValue(ctx)
        if !ok </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.PostTodos500JSONResponse{InternalServerErrorResponseJSONResponse: res}, errors.New("fail to load context value")
        }</span>
        <span class="cov8" title="1">statusCode, err := todosHandler.todoService.CreateTodo(ctx, *request.Body, userID)

        switch statusCode </span>{
        case http.StatusBadRequest:<span class="cov8" title="1">
                validationErrors := todosHandler.mappingValidationErrorStruct(err)
                return apis.PostTodos400JSONResponse{Code: http.StatusBadRequest, Errors: validationErrors}, nil</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return apis.PostTodos400JSONResponse{Code: http.StatusInternalServerError, Errors: apis.StoreTodoValidationError{}}, err</span>
        }

        <span class="cov8" title="1">res := apis.StoreTodoResponseJSONResponse{ Code: http.StatusOK, Errors: apis.StoreTodoValidationError{} }
        return apis.PostTodos200JSONResponse{StoreTodoResponseJSONResponse: res}, nil</span>
}

func (todosHandler *todosHandler) GetTodo(ctx context.Context, request apis.GetTodoRequestObject) (apis.GetTodoResponseObject, error) <span class="cov8" title="1">{
        intID, err := strconv.Atoi(request.Id)
        if err != nil </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError, Message: err.Error()}
                return apis.GetTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, err
        }</span>

        <span class="cov8" title="1">userID, ok := utils.ContextValue(ctx)
        if !ok </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.GetTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, errors.New("fail to load context value")
        }</span>

        <span class="cov8" title="1">statusCode, todo := todosHandler.todoService.ShowTodo(ctx, int64(intID), userID)
        switch statusCode </span>{
        case http.StatusNotFound:<span class="cov8" title="1">
                res := apis.NotFoundErrorResponseJSONResponse{Code: http.StatusNotFound}
                return apis.GetTodo404JSONResponse{NotFoundErrorResponseJSONResponse: res}, nil</span>
        }

        <span class="cov8" title="1">resTodo := apis.Todo{Id: int(todo.ID), Title: todo.Title, Content: todo.Content.String}
        res := apis.ShowTodoResponseJSONResponse{Todo: resTodo}
        return apis.GetTodo200JSONResponse{ShowTodoResponseJSONResponse: res}, nil</span>
}

func (todosHandler *todosHandler) PatchTodo(ctx context.Context, request apis.PatchTodoRequestObject) (apis.PatchTodoResponseObject, error) <span class="cov8" title="1">{
        intID, err := strconv.Atoi(request.Id)
        if err != nil </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError, Message: err.Error()}
                return apis.PatchTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, err
        }</span>

        <span class="cov8" title="1">userID, ok := utils.ContextValue(ctx)
        if !ok </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.PatchTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, errors.New("fail to load context value")
        }</span>

        <span class="cov8" title="1">statusCode, err := todosHandler.todoService.UpdateTodo(ctx, int64(intID), *request.Body, userID)

        switch statusCode </span>{
        case http.StatusBadRequest:<span class="cov8" title="1">
                validationErrors := todosHandler.mappingValidationErrorStruct(err)
                return apis.PatchTodo400JSONResponse{Code: http.StatusBadRequest, Errors: validationErrors}, nil</span>
        case http.StatusNotFound:<span class="cov8" title="1">
                res := apis.NotFoundErrorResponseJSONResponse{Code: http.StatusNotFound}
                return apis.PatchTodo404JSONResponse{NotFoundErrorResponseJSONResponse: res}, nil</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.PatchTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, err</span>
        }

        <span class="cov8" title="1">res := apis.StoreTodoResponseJSONResponse{ Code: http.StatusOK, Errors: apis.StoreTodoValidationError{} }
        return apis.PatchTodo200JSONResponse{StoreTodoResponseJSONResponse: res}, nil</span>
}

func (todosHandler *todosHandler) DeleteTodo(ctx context.Context, request apis.DeleteTodoRequestObject) (apis.DeleteTodoResponseObject, error) <span class="cov8" title="1">{
        intID, err := strconv.Atoi(request.Id)
        if err != nil </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError, Message: err.Error()}
                return apis.DeleteTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, err
        }</span>

        <span class="cov8" title="1">userID, ok := utils.ContextValue(ctx)
        if !ok </span><span class="cov0" title="0">{
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.DeleteTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, errors.New("fail to load context value")
        }</span>

        <span class="cov8" title="1">statusCode, err := todosHandler.todoService.DeleteTodo(ctx, int64(intID), userID)

        switch statusCode </span>{
        case http.StatusNotFound:<span class="cov8" title="1">
                res := apis.NotFoundErrorResponseJSONResponse{Code: http.StatusNotFound}
                return apis.DeleteTodo404JSONResponse{NotFoundErrorResponseJSONResponse: res}, nil</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                res := apis.InternalServerErrorResponseJSONResponse{Code: http.StatusInternalServerError}
                return apis.DeleteTodo500JSONResponse{InternalServerErrorResponseJSONResponse: res}, err</span>
        }

        <span class="cov8" title="1">res := apis.DeleteTodoResponseJSONResponse{ Code: http.StatusOK, Result: true }
        return apis.DeleteTodo200JSONResponse{DeleteTodoResponseJSONResponse: res}, nil</span>
}

func (todosHandler *todosHandler) mappingValidationErrorStruct(err error) apis.StoreTodoValidationError <span class="cov8" title="1">{
        var validationError apis.StoreTodoValidationError
        if err == nil </span><span class="cov0" title="0">{
                return validationError
        }</span>

        <span class="cov8" title="1">if errors, ok := err.(validation.Errors); ok </span><span class="cov8" title="1">{
                // NOTE: レスポンス用の構造体にマッピング
                for field, err := range errors </span><span class="cov8" title="1">{
                        messages := []string{err.Error()}
                        switch field </span>{
                        case "title":<span class="cov8" title="1">
                                validationError.Title = &amp;messages</span>
                        case "content":<span class="cov0" title="0">
                                validationError.Content = &amp;messages</span>
                        }
                }
        }
        <span class="cov8" title="1">return validationError</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "app/db"
        "app/middlewares"
        models "app/models/generated"
        apis "app/openapi"
        "app/services"
        "app/test/factories"
        "app/utils/routers"
        "context"
        "database/sql"

        "github.com/DATA-DOG/go-txdb"
        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/testutil"
        "github.com/stretchr/testify/suite"
        "github.com/volatiletech/sqlboiler/v4/boil"
)

type WithDBSuite struct {
        suite.Suite
}

var (
        DBCon *sql.DB
        ctx   context.Context
        user *models.User
        token string
        e *echo.Echo
        csrfToken string
        csrfTokenCookie string
)

// func (s *WithDBSuite) SetupSuite()                           {} // テストスイート実施前の処理
// func (s *WithDBSuite) TearDownSuite()                        {} // テストスイート終了後の処理
// func (s *WithDBSuite) SetupTest()                            {} // テストケース実施前の処理
// func (s *WithDBSuite) TearDownTest()                         {} // テストケース終了後の処理
// func (s *WithDBSuite) BeforeTest(suiteName, testName string) {} // テストケース実施前の処理
// func (s *WithDBSuite) AfterTest(suiteName, testName string)  {} // テストケース終了後の処理

func init() <span class="cov8" title="1">{
        txdb.Register("txdb-controller", "mysql", db.GetDsn())
        ctx = context.Background()

        e = routers.ApplyMiddlewares(echo.New())
}</span>

func (s *WithDBSuite) SetDBCon() <span class="cov8" title="1">{
        db, err := sql.Open("txdb-controller", "connect")
        if err != nil </span><span class="cov0" title="0">{
                s.T().Fatalf("failed to initialize DB: %v", err)
        }</span>
        <span class="cov8" title="1">DBCon = db</span>
}

func (s *WithDBSuite) CloseDB() <span class="cov8" title="1">{
        DBCon.Close()
}</span>

func (s *WithDBSuite) SignIn() <span class="cov8" title="1">{
        // NOTE: テスト用ユーザの作成
        user = factories.UserFactory.MustCreateWithOption(map[string]interface{}{"Email": "test@example.com"}).(*models.User)
        if err := user.Insert(ctx, DBCon, boil.Infer()); err != nil </span><span class="cov0" title="0">{
                s.T().Fatalf("failed to create test user %v", err)
        }</span>
        
        <span class="cov8" title="1">reqBody := apis.SignInInput{
                Email: "test@example.com",
                Password: "password",
        }
        result := testutil.NewRequest().Post("/auth/signIn").WithHeader("Cookie", csrfTokenCookie).WithHeader(echo.HeaderXCSRFToken, csrfToken).WithJsonBody(reqBody).GoWithHTTPHandler(s.T(), e)
        token = result.Recorder.Result().Header.Values("Set-Cookie")[0]</span>        
}

func (s *WithDBSuite) SetCsrfHeaderValues() <span class="cov8" title="1">{
        result := testutil.NewRequest().Get("/auth/csrf").GoWithHTTPHandler(s.T(), e)

        var res apis.GetAuthCsrf200JSONResponse
        err := result.UnmarshalJsonToObject(&amp;res)
        if err != nil </span><span class="cov0" title="0">{
                s.T().Error(err.Error())
        }</span>

        <span class="cov8" title="1">csrfToken = res.CsrfToken
        csrfTokenCookie = result.Recorder.Result().Header.Values("Set-Cookie")[0]</span>
}

func (s *WithDBSuite) initializeHandlers() <span class="cov8" title="1">{
        authService := services.NewAuthService(DBCon)
        testAuthHandler := NewAuthHandler(authService)

        todoService := services.NewTodoService(DBCon)
        testTodosHandler := NewTodosHandler(todoService)

        mainHandler := NewMainHandler(testAuthHandler, testTodosHandler)

        strictHandler := apis.NewStrictHandler(mainHandler, []apis.StrictMiddlewareFunc{middlewares.AuthMiddleware})
        apis.RegisterHandlers(e, strictHandler)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "app/db"
        "app/handlers"
        "app/middlewares"
        apis "app/openapi"
        "app/services"
        "app/utils/routers"
        "os"

        "github.com/joho/godotenv"
        "github.com/labstack/echo/v4"
)

func main() <span class="cov0" title="0">{
        loadEnv()

        dbCon := db.Init()
        e := echo.New()

        // NOTE: service層のインスタンス
        authService := services.NewAuthService(dbCon)
        todoService := services.NewTodoService(dbCon)

        // NOTE: controllerをHandlerに追加
        authHandler := handlers.NewAuthHandler(authService)
        todosHandler := handlers.NewTodosHandler(todoService)

        appliedMiddlewareEcho := routers.ApplyMiddlewares(e)

        mainHandler := handlers.NewMainHandler(authHandler, todosHandler)
        mainStrictHandler := apis.NewStrictHandler(mainHandler, []apis.StrictMiddlewareFunc{middlewares.AuthMiddleware})
        apis.RegisterHandlers(appliedMiddlewareEcho, mainStrictHandler)

        appliedMiddlewareEcho.Logger.Fatal(appliedMiddlewareEcho.Start(":" + os.Getenv("SERVER_PORT")))
}</span>

func loadEnv() <span class="cov0" title="0">{
        envFilePath := os.Getenv("ENV_FILE_PATH")
        if envFilePath == "" </span><span class="cov0" title="0">{
                envFilePath = ".env"
        }</span>
        <span class="cov0" title="0">godotenv.Load(envFilePath)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middlewares

import (
        apis "app/openapi"
        "app/utils"
        "context"
        "fmt"
        "net/http"
        "os"

        "github.com/golang-jwt/jwt"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

func AuthMiddleware(f apis.StrictHandlerFunc, operationID string) apis.StrictHandlerFunc <span class="cov8" title="1">{
    return func(ctx echo.Context, i interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                if !needsAuthenticate(operationID) </span><span class="cov8" title="1">{
                        // NOTE: 認証が不要なURIは認証をスキップ
                        return f(ctx, i)
                }</span>
                
        // NOTE: Cookieからtokenを取得し、JWTの復号
                <span class="cov8" title="1">tokenString, _ := ctx.Cookie("token")
                if tokenString == nil </span><span class="cov8" title="1">{
                        return nil, echo.ErrUnauthorized
                }</span>

                <span class="cov8" title="1">token, _ := jwt.Parse(tokenString.Value, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>
                        <span class="cov8" title="1">return []byte(os.Getenv("JWT_TOKEN_KEY")), nil</span>
                })

                // NOTE: userIDをContextにセット
                <span class="cov8" title="1">var userID int
                if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                        userID = int(claims["user_id"].(float64))
                }</span>

                // NOTE: contextにuserIDを格納する
                //     : コントローラ側ではcontext.Context型のため、withValue - Valueで行う
                <span class="cov8" title="1">c := utils.NewContext(ctx.Request().Context(), userID)
                ctx.SetRequest(ctx.Request().WithContext(c))
        return f(ctx, i)</span>
    }
}

// CSRFContextMiddleware ... CSRFトークンを context.Context に埋め込むミドルウェア
func CSRFContextMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov8" title="1">{
        return func(c echo.Context) error </span><span class="cov8" title="1">{
                // NOTE: EchoのcontextからCSRFトークンを取得
                token, ok := c.Get(middleware.DefaultCSRFConfig.ContextKey).(string)
                if !ok </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusInternalServerError, "Failed to retrieve CSRF token")
                }</span>

                // NOTE: context.Context に CSRF トークンを埋め込む
                //lint:ignore SA1029 It's ok because ContextKey
                <span class="cov8" title="1">ctx := context.WithValue(c.Request().Context(), middleware.DefaultCSRFConfig.ContextKey, token)
                c.SetRequest(c.Request().WithContext(ctx))

                return next(c)</span>
        }
}

func needsAuthenticate(operationID string) (bool) <span class="cov8" title="1">{
        spec, _ := apis.GetSwagger()
        for _, pathItem := range spec.Paths.Map() </span><span class="cov8" title="1">{
                for _, op := range pathItem.Operations() </span><span class="cov8" title="1">{
                        if op.OperationID != operationID </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">return len(*op.Security) &gt; 0</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "unsafe"

        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

const (
        MaxPageSize = 65000
)

var (
        DefaultPageSize = 1000
)

type queryMods []qm.QueryMod

func (m queryMods) Apply(q *queries.Query) <span class="cov0" title="0">{
        for _, mod := range m </span><span class="cov0" title="0">{
                mod.Apply(q)
        }</span>
}

func chunkSlice[T any](slice []T, chunkSize int) [][]T <span class="cov0" title="0">{
        total := len(slice)
        if total == 0 </span><span class="cov0" title="0">{
                return [][]T{}
        }</span>
        <span class="cov0" title="0">if total &lt;= chunkSize </span><span class="cov0" title="0">{
                return [][]T{slice}
        }</span>

        <span class="cov0" title="0">chunks := make([][]T, 0, total/chunkSize+1)
        for </span><span class="cov0" title="0">{
                if len(slice) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if len(slice) &lt; chunkSize </span><span class="cov0" title="0">{
                        chunkSize = len(slice)
                }</span>

                <span class="cov0" title="0">chunks = append(chunks, slice[0:chunkSize])
                slice = slice[chunkSize:]</span>
        }

        <span class="cov0" title="0">return chunks</span>
}

func SplitInChunks[T any](slice []T) [][]T <span class="cov0" title="0">{
        return chunkSlice(slice, DefaultPageSize)
}</span>

func SplitInChunksBySize[T any](slice []T, chunkSize int) [][]T <span class="cov0" title="0">{
        return chunkSlice(slice, chunkSize)
}</span>

func unsafeGetString(b []byte) string <span class="cov0" title="0">{
        return *(*string)(unsafe.Pointer(&amp;b))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "regexp"

        "github.com/volatiletech/sqlboiler/v4/drivers"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

var dialect = drivers.Dialect{
        LQ: 0x60,
        RQ: 0x60,

        UseIndexPlaceholders:    false,
        UseLastInsertID:         true,
        UseSchema:               false,
        UseDefaultKeyword:       false,
        UseAutoColumns:          false,
        UseTopClause:            false,
        UseOutputClause:         false,
        UseCaseWhenExistsClause: false,
}

// This is a dummy variable to prevent unused regexp import error
var _ = &amp;regexp.Regexp{}

// NewQuery initializes a new Query using the passed in QueryMods
func NewQuery(mods ...qm.QueryMod) *queries.Query <span class="cov8" title="1">{
        q := &amp;queries.Query{}
        queries.SetDialect(q, &amp;dialect)
        qm.Apply(q, mods...)

        return q
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "strconv"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/strmangle"
)

// M type is for providing columns and column values to UpdateAll.
type M map[string]interface{}

// ErrSyncFail occurs during insert when the record could not be retrieved in
// order to populate default value information. This usually happens when LastInsertId
// fails or there was a primary key configuration that was not resolvable.
var ErrSyncFail = errors.New("models: failed to synchronize data after insert")

type insertCache struct {
        query        string
        retQuery     string
        valueMapping []uint64
        retMapping   []uint64
}

type updateCache struct {
        query        string
        valueMapping []uint64
}

func makeCacheKey(cols boil.Columns, nzDefaults []string) string <span class="cov8" title="1">{
        buf := strmangle.GetBuffer()

        buf.WriteString(strconv.Itoa(cols.Kind))
        for _, w := range cols.Cols </span><span class="cov0" title="0">{
                buf.WriteString(w)
        }</span>

        <span class="cov8" title="1">if len(nzDefaults) != 0 </span><span class="cov0" title="0">{
                buf.WriteByte('.')
        }</span>
        <span class="cov8" title="1">for _, nz := range nzDefaults </span><span class="cov0" title="0">{
                buf.WriteString(nz)
        }</span>

        <span class="cov8" title="1">str := buf.String()
        strmangle.PutBuffer(buf)
        return str</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// GorpMigration is an object representing the database table.
type GorpMigration struct {
        ID        string    `boil:"id" json:"id" toml:"id" yaml:"id"`
        AppliedAt null.Time `boil:"applied_at" json:"applied_at,omitempty" toml:"applied_at" yaml:"applied_at,omitempty"`

        R *gorpMigrationR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L gorpMigrationL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var GorpMigrationColumns = struct {
        ID        string
        AppliedAt string
}{
        ID:        "id",
        AppliedAt: "applied_at",
}

var GorpMigrationTableColumns = struct {
        ID        string
        AppliedAt string
}{
        ID:        "gorp_migrations.id",
        AppliedAt: "gorp_migrations.applied_at",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.EQ, x) }</span>
func (w whereHelperstring) NEQ(x string) qm.QueryMod   <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.NEQ, x) }</span>
func (w whereHelperstring) LT(x string) qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LT, x) }</span>
func (w whereHelperstring) LTE(x string) qm.QueryMod   <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LTE, x) }</span>
func (w whereHelperstring) GT(x string) qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GT, x) }</span>
func (w whereHelperstring) GTE(x string) qm.QueryMod   <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GTE, x) }</span>
func (w whereHelperstring) LIKE(x string) qm.QueryMod  <span class="cov0" title="0">{ return qm.Where(w.field+" LIKE ?", x) }</span>
func (w whereHelperstring) NLIKE(x string) qm.QueryMod <span class="cov0" title="0">{ return qm.Where(w.field+" NOT LIKE ?", x) }</span>
func (w whereHelperstring) IN(slice []string) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, false, x)
}</span>
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, true, x)
}</span>
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>

func (w whereHelpernull_Time) IsNull() qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.WhereIsNull(w.field) }</span>
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod <span class="cov0" title="0">{ return qmhelper.WhereIsNotNull(w.field) }</span>

var GorpMigrationWhere = struct {
        ID        whereHelperstring
        AppliedAt whereHelpernull_Time
}{
        ID:        whereHelperstring{field: "`gorp_migrations`.`id`"},
        AppliedAt: whereHelpernull_Time{field: "`gorp_migrations`.`applied_at`"},
}

// GorpMigrationRels is where relationship names are stored.
var GorpMigrationRels = struct {
}{}

// gorpMigrationR is where relationships are stored.
type gorpMigrationR struct {
}

// NewStruct creates a new relationship struct
func (*gorpMigrationR) NewStruct() *gorpMigrationR <span class="cov0" title="0">{
        return &amp;gorpMigrationR{}
}</span>

// gorpMigrationL is where Load methods for each relationship are stored.
type gorpMigrationL struct{}

var (
        gorpMigrationAllColumns            = []string{"id", "applied_at"}
        gorpMigrationColumnsWithoutDefault = []string{"id", "applied_at"}
        gorpMigrationColumnsWithDefault    = []string{}
        gorpMigrationPrimaryKeyColumns     = []string{"id"}
        gorpMigrationGeneratedColumns      = []string{}
)

type (
        // GorpMigrationSlice is an alias for a slice of pointers to GorpMigration.
        // This should almost always be used instead of []GorpMigration.
        GorpMigrationSlice []*GorpMigration
        // GorpMigrationHook is the signature for custom GorpMigration hook methods
        GorpMigrationHook func(context.Context, boil.ContextExecutor, *GorpMigration) error

        gorpMigrationQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        gorpMigrationType                 = reflect.TypeOf(&amp;GorpMigration{})
        gorpMigrationMapping              = queries.MakeStructMapping(gorpMigrationType)
        gorpMigrationPrimaryKeyMapping, _ = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, gorpMigrationPrimaryKeyColumns)
        gorpMigrationInsertCacheMut       sync.RWMutex
        gorpMigrationInsertCache          = make(map[string]insertCache)
        gorpMigrationUpdateCacheMut       sync.RWMutex
        gorpMigrationUpdateCache          = make(map[string]updateCache)
        gorpMigrationUpsertCacheMut       sync.RWMutex
        gorpMigrationUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var gorpMigrationAfterSelectMu sync.Mutex
var gorpMigrationAfterSelectHooks []GorpMigrationHook

var gorpMigrationBeforeInsertMu sync.Mutex
var gorpMigrationBeforeInsertHooks []GorpMigrationHook
var gorpMigrationAfterInsertMu sync.Mutex
var gorpMigrationAfterInsertHooks []GorpMigrationHook

var gorpMigrationBeforeUpdateMu sync.Mutex
var gorpMigrationBeforeUpdateHooks []GorpMigrationHook
var gorpMigrationAfterUpdateMu sync.Mutex
var gorpMigrationAfterUpdateHooks []GorpMigrationHook

var gorpMigrationBeforeDeleteMu sync.Mutex
var gorpMigrationBeforeDeleteHooks []GorpMigrationHook
var gorpMigrationAfterDeleteMu sync.Mutex
var gorpMigrationAfterDeleteHooks []GorpMigrationHook

var gorpMigrationBeforeUpsertMu sync.Mutex
var gorpMigrationBeforeUpsertHooks []GorpMigrationHook
var gorpMigrationAfterUpsertMu sync.Mutex
var gorpMigrationAfterUpsertHooks []GorpMigrationHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *GorpMigration) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationAfterSelectHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *GorpMigration) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationBeforeInsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *GorpMigration) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationAfterInsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *GorpMigration) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationBeforeUpdateHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *GorpMigration) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationAfterUpdateHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *GorpMigration) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationBeforeDeleteHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *GorpMigration) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationAfterDeleteHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *GorpMigration) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationBeforeUpsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *GorpMigration) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range gorpMigrationAfterUpsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AddGorpMigrationHook registers your hook function for all future operations.
func AddGorpMigrationHook(hookPoint boil.HookPoint, gorpMigrationHook GorpMigrationHook) <span class="cov0" title="0">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov0" title="0">
                gorpMigrationAfterSelectMu.Lock()
                gorpMigrationAfterSelectHooks = append(gorpMigrationAfterSelectHooks, gorpMigrationHook)
                gorpMigrationAfterSelectMu.Unlock()</span>
        case boil.BeforeInsertHook:<span class="cov0" title="0">
                gorpMigrationBeforeInsertMu.Lock()
                gorpMigrationBeforeInsertHooks = append(gorpMigrationBeforeInsertHooks, gorpMigrationHook)
                gorpMigrationBeforeInsertMu.Unlock()</span>
        case boil.AfterInsertHook:<span class="cov0" title="0">
                gorpMigrationAfterInsertMu.Lock()
                gorpMigrationAfterInsertHooks = append(gorpMigrationAfterInsertHooks, gorpMigrationHook)
                gorpMigrationAfterInsertMu.Unlock()</span>
        case boil.BeforeUpdateHook:<span class="cov0" title="0">
                gorpMigrationBeforeUpdateMu.Lock()
                gorpMigrationBeforeUpdateHooks = append(gorpMigrationBeforeUpdateHooks, gorpMigrationHook)
                gorpMigrationBeforeUpdateMu.Unlock()</span>
        case boil.AfterUpdateHook:<span class="cov0" title="0">
                gorpMigrationAfterUpdateMu.Lock()
                gorpMigrationAfterUpdateHooks = append(gorpMigrationAfterUpdateHooks, gorpMigrationHook)
                gorpMigrationAfterUpdateMu.Unlock()</span>
        case boil.BeforeDeleteHook:<span class="cov0" title="0">
                gorpMigrationBeforeDeleteMu.Lock()
                gorpMigrationBeforeDeleteHooks = append(gorpMigrationBeforeDeleteHooks, gorpMigrationHook)
                gorpMigrationBeforeDeleteMu.Unlock()</span>
        case boil.AfterDeleteHook:<span class="cov0" title="0">
                gorpMigrationAfterDeleteMu.Lock()
                gorpMigrationAfterDeleteHooks = append(gorpMigrationAfterDeleteHooks, gorpMigrationHook)
                gorpMigrationAfterDeleteMu.Unlock()</span>
        case boil.BeforeUpsertHook:<span class="cov0" title="0">
                gorpMigrationBeforeUpsertMu.Lock()
                gorpMigrationBeforeUpsertHooks = append(gorpMigrationBeforeUpsertHooks, gorpMigrationHook)
                gorpMigrationBeforeUpsertMu.Unlock()</span>
        case boil.AfterUpsertHook:<span class="cov0" title="0">
                gorpMigrationAfterUpsertMu.Lock()
                gorpMigrationAfterUpsertHooks = append(gorpMigrationAfterUpsertHooks, gorpMigrationHook)
                gorpMigrationAfterUpsertMu.Unlock()</span>
        }
}

// One returns a single gorpMigration record from the query.
func (q gorpMigrationQuery) One(ctx context.Context, exec boil.ContextExecutor) (*GorpMigration, error) <span class="cov0" title="0">{
        o := &amp;GorpMigration{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for gorp_migrations")</span>
        }

        <span class="cov0" title="0">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov0" title="0">return o, nil</span>
}

// All returns all GorpMigration records from the query.
func (q gorpMigrationQuery) All(ctx context.Context, exec boil.ContextExecutor) (GorpMigrationSlice, error) <span class="cov0" title="0">{
        var o []*GorpMigration

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to GorpMigration slice")
        }</span>

        <span class="cov0" title="0">if len(gorpMigrationAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return o, nil</span>
}

// Count returns the count of all GorpMigration records in the query.
func (q gorpMigrationQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count gorp_migrations rows")
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// Exists checks if the row exists in the table.
func (q gorpMigrationQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if gorp_migrations exists")
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// GorpMigrations retrieves all the records using an executor.
func GorpMigrations(mods ...qm.QueryMod) gorpMigrationQuery <span class="cov0" title="0">{
        mods = append(mods, qm.From("`gorp_migrations`"))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov0" title="0">{
                queries.SetSelect(q, []string{"`gorp_migrations`.*"})
        }</span>

        <span class="cov0" title="0">return gorpMigrationQuery{q}</span>
}

// FindGorpMigration retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindGorpMigration(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*GorpMigration, error) <span class="cov0" title="0">{
        gorpMigrationObj := &amp;GorpMigration{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov0" title="0">query := fmt.Sprintf(
                "select %s from `gorp_migrations` where `id`=?", sel,
        )

        q := queries.Raw(query, iD)

        err := q.Bind(ctx, exec, gorpMigrationObj)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from gorp_migrations")</span>
        }

        <span class="cov0" title="0">if err = gorpMigrationObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return gorpMigrationObj, err
        }</span>

        <span class="cov0" title="0">return gorpMigrationObj, nil</span>
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *GorpMigration) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no gorp_migrations provided for insertion")
        }</span>

        <span class="cov0" title="0">var err error

        if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nzDefaults := queries.NonZeroDefaultSet(gorpMigrationColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        gorpMigrationInsertCacheMut.RLock()
        cache, cached := gorpMigrationInsertCache[key]
        gorpMigrationInsertCacheMut.RUnlock()

        if !cached </span><span class="cov0" title="0">{
                wl, returnColumns := columns.InsertColumnSet(
                        gorpMigrationAllColumns,
                        gorpMigrationColumnsWithDefault,
                        gorpMigrationColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cache.retMapping, err = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(wl) != 0 </span><span class="cov0" title="0">{
                        cache.query = fmt.Sprintf("INSERT INTO `gorp_migrations` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO `gorp_migrations` () VALUES ()%s%s"
                }</span>

                <span class="cov0" title="0">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                        cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `gorp_migrations` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, gorpMigrationPrimaryKeyColumns))
                }</span>

                <span class="cov0" title="0">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov0" title="0">_, err = exec.ExecContext(ctx, cache.query, vals...)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into gorp_migrations")
        }</span>

        <span class="cov0" title="0">var identifierCols []interface{}

        if len(cache.retMapping) == 0 </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">identifierCols = []interface{}{
                o.ID,
        }

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.retQuery)
                fmt.Fprintln(writer, identifierCols...)
        }</span>
        <span class="cov0" title="0">err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to populate default values for gorp_migrations")
        }</span>

CacheNoHooks:
        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                gorpMigrationInsertCacheMut.Lock()
                gorpMigrationInsertCache[key] = cache
                gorpMigrationInsertCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return o.doAfterInsertHooks(ctx, exec)</span>
}

// Update uses an executor to update the GorpMigration.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *GorpMigration) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">key := makeCacheKey(columns, nil)
        gorpMigrationUpdateCacheMut.RLock()
        cache, cached := gorpMigrationUpdateCache[key]
        gorpMigrationUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov0" title="0">{
                wl := columns.UpdateColumnSet(
                        gorpMigrationAllColumns,
                        gorpMigrationPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov0" title="0">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov0" title="0">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update gorp_migrations, could not build whitelist")
                }</span>

                <span class="cov0" title="0">cache.query = fmt.Sprintf("UPDATE `gorp_migrations` SET %s WHERE %s",
                        strmangle.SetParamNames("`", "`", 0, wl),
                        strmangle.WhereClause("`", "`", 0, gorpMigrationPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, append(wl, gorpMigrationPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov0" title="0">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update gorp_migrations row")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for gorp_migrations")
        }</span>

        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                gorpMigrationUpdateCacheMut.Lock()
                gorpMigrationUpdateCache[key] = cache
                gorpMigrationUpdateCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAll updates all rows with the specified column values.
func (q gorpMigrationQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for gorp_migrations")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for gorp_migrations")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o GorpMigrationSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov0" title="0">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov0" title="0">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov0" title="0">for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gorpMigrationPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := fmt.Sprintf("UPDATE `gorp_migrations` SET %s WHERE %s",
                strmangle.SetParamNames("`", "`", 0, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, gorpMigrationPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in gorpMigration slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all gorpMigration")
        }</span>
        <span class="cov0" title="0">return rowsAff, nil</span>
}

var mySQLGorpMigrationUniqueColumns = []string{
        "id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *GorpMigration) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no gorp_migrations provided for upsert")
        }</span>

        <span class="cov0" title="0">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nzDefaults := queries.NonZeroDefaultSet(gorpMigrationColumnsWithDefault, o)
        nzUniques := queries.NonZeroDefaultSet(mySQLGorpMigrationUniqueColumns, o)

        if len(nzUniques) == 0 </span><span class="cov0" title="0">{
                return errors.New("cannot upsert with a table that cannot conflict on a unique column")
        }</span>

        // Build cache key in-line uglily - mysql vs psql problems
        <span class="cov0" title="0">buf := strmangle.GetBuffer()
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzUniques </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">key := buf.String()
        strmangle.PutBuffer(buf)

        gorpMigrationUpsertCacheMut.RLock()
        cache, cached := gorpMigrationUpsertCache[key]
        gorpMigrationUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov0" title="0">{
                insert, _ := insertColumns.InsertColumnSet(
                        gorpMigrationAllColumns,
                        gorpMigrationColumnsWithDefault,
                        gorpMigrationColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        gorpMigrationAllColumns,
                        gorpMigrationPrimaryKeyColumns,
                )

                if !updateColumns.IsNone() &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert gorp_migrations, could not build update column list")
                }</span>

                <span class="cov0" title="0">ret := strmangle.SetComplement(gorpMigrationAllColumns, strmangle.SetIntersect(insert, update))

                cache.query = buildUpsertQueryMySQL(dialect, "`gorp_migrations`", update, insert)
                cache.retQuery = fmt.Sprintf(
                        "SELECT %s FROM `gorp_migrations` WHERE %s",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
                        strmangle.WhereClause("`", "`", 0, nzUniques),
                )

                cache.valueMapping, err = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(ret) != 0 </span><span class="cov0" title="0">{
                        cache.retMapping, err = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov0" title="0">_, err = exec.ExecContext(ctx, cache.query, vals...)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert for gorp_migrations")
        }</span>

        <span class="cov0" title="0">var uniqueMap []uint64
        var nzUniqueCols []interface{}

        if len(cache.retMapping) == 0 </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">uniqueMap, err = queries.BindMapping(gorpMigrationType, gorpMigrationMapping, nzUniques)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to retrieve unique values for gorp_migrations")
        }</span>
        <span class="cov0" title="0">nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.retQuery)
                fmt.Fprintln(writer, nzUniqueCols...)
        }</span>
        <span class="cov0" title="0">err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to populate default values for gorp_migrations")
        }</span>

CacheNoHooks:
        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                gorpMigrationUpsertCacheMut.Lock()
                gorpMigrationUpsertCache[key] = cache
                gorpMigrationUpsertCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// Delete deletes a single GorpMigration record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *GorpMigration) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no GorpMigration provided for delete")
        }</span>

        <span class="cov0" title="0">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), gorpMigrationPrimaryKeyMapping)
        sql := "DELETE FROM `gorp_migrations` WHERE `id`=?"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from gorp_migrations")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for gorp_migrations")
        }</span>

        <span class="cov0" title="0">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAll deletes all matching rows.
func (q gorpMigrationQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no gorpMigrationQuery provided for delete all")
        }</span>

        <span class="cov0" title="0">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from gorp_migrations")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for gorp_migrations")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o GorpMigrationSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(gorpMigrationBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">var args []interface{}
        for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gorpMigrationPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := "DELETE FROM `gorp_migrations` WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, gorpMigrationPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from gorpMigration slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for gorp_migrations")
        }</span>

        <span class="cov0" title="0">if len(gorpMigrationAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *GorpMigration) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov0" title="0">{
        ret, err := FindGorpMigration(ctx, exec, o.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*o = *ret
        return nil</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *GorpMigrationSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov0" title="0">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">slice := GorpMigrationSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gorpMigrationPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := "SELECT `gorp_migrations`.* FROM `gorp_migrations` WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, gorpMigrationPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in GorpMigrationSlice")
        }</span>

        <span class="cov0" title="0">*o = slice

        return nil</span>
}

// GorpMigrationExists checks if the GorpMigration row exists.
func GorpMigrationExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) <span class="cov0" title="0">{
        var exists bool
        sql := "select exists(select 1 from `gorp_migrations` where `id`=? limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, iD)
        }</span>
        <span class="cov0" title="0">row := exec.QueryRowContext(ctx, sql, iD)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if gorp_migrations exists")
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// Exists checks if the GorpMigration row exists.
func (o *GorpMigration) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return GorpMigrationExists(ctx, exec, o.ID)
}</span>

// /////////////////////////////// BEGIN EXTENSIONS /////////////////////////////////
// Expose table columns
var (
        GorpMigrationAllColumns            = gorpMigrationAllColumns
        GorpMigrationColumnsWithoutDefault = gorpMigrationColumnsWithoutDefault
        GorpMigrationColumnsWithDefault    = gorpMigrationColumnsWithDefault
        GorpMigrationPrimaryKeyColumns     = gorpMigrationPrimaryKeyColumns
        GorpMigrationGeneratedColumns      = gorpMigrationGeneratedColumns
)

// GetID get ID from model object
func (o *GorpMigration) GetID() string <span class="cov0" title="0">{
        return o.ID
}</span>

// GetIDs extract IDs from model objects
func (s GorpMigrationSlice) GetIDs() []string <span class="cov0" title="0">{
        result := make([]string, len(s))
        for i := range s </span><span class="cov0" title="0">{
                result[i] = s[i].ID
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetIntfIDs extract IDs from model objects as interface slice
func (s GorpMigrationSlice) GetIntfIDs() []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, len(s))
        for i := range s </span><span class="cov0" title="0">{
                result[i] = s[i].ID
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToIDMap convert a slice of model objects to a map with ID as key
func (s GorpMigrationSlice) ToIDMap() map[string]*GorpMigration <span class="cov0" title="0">{
        result := make(map[string]*GorpMigration, len(s))
        for _, o := range s </span><span class="cov0" title="0">{
                result[o.ID] = o
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToUniqueItems construct a slice of unique items from the given slice
func (s GorpMigrationSlice) ToUniqueItems() GorpMigrationSlice <span class="cov0" title="0">{
        result := make(GorpMigrationSlice, 0, len(s))
        mapChk := make(map[string]struct{}, len(s))
        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                o := s[i]
                if _, ok := mapChk[o.ID]; !ok </span><span class="cov0" title="0">{
                        mapChk[o.ID] = struct{}{}
                        result = append(result, o)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// FindItemByID find item by ID in the slice
func (s GorpMigrationSlice) FindItemByID(id string) *GorpMigration <span class="cov0" title="0">{
        for _, o := range s </span><span class="cov0" title="0">{
                if o.ID == id </span><span class="cov0" title="0">{
                        return o
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindMissingItemIDs find all item IDs that are not in the list
// NOTE: the input ID slice should contain unique values
func (s GorpMigrationSlice) FindMissingItemIDs(expectedIDs []string) []string <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return expectedIDs
        }</span>
        <span class="cov0" title="0">result := []string{}
        mapChk := s.ToIDMap()
        for _, id := range expectedIDs </span><span class="cov0" title="0">{
                if _, ok := mapChk[id]; !ok </span><span class="cov0" title="0">{
                        result = append(result, id)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// InsertAll inserts all rows with the specified column values, using an executor.
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o GorpMigrationSlice) InsertAll(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Calculate the widest columns from all rows need to insert
        <span class="cov0" title="0">wlCols := make(map[string]struct{}, 10)
        for _, row := range o </span><span class="cov0" title="0">{
                wl, _ := columns.InsertColumnSet(
                        gorpMigrationAllColumns,
                        gorpMigrationColumnsWithDefault,
                        gorpMigrationColumnsWithoutDefault,
                        queries.NonZeroDefaultSet(gorpMigrationColumnsWithDefault, row),
                )
                for _, col := range wl </span><span class="cov0" title="0">{
                        wlCols[col] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">wl := make([]string, 0, len(wlCols))
        for _, col := range gorpMigrationAllColumns </span><span class="cov0" title="0">{
                if _, ok := wlCols[col]; ok </span><span class="cov0" title="0">{
                        wl = append(wl, col)
                }</span>
        }

        <span class="cov0" title="0">var sql string
        vals := []interface{}{}
        for i, row := range o </span><span class="cov0" title="0">{

                if err := row.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">if i == 0 </span><span class="cov0" title="0">{
                        sql = "INSERT INTO `gorp_migrations` " + "(`" + strings.Join(wl, "`,`") + "`)" + " VALUES "
                }</span>
                <span class="cov0" title="0">sql += strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), len(vals)+1, len(wl))
                if i != len(o)-1 </span><span class="cov0" title="0">{
                        sql += ","
                }</span>
                <span class="cov0" title="0">valMapping, err := queries.BindMapping(gorpMigrationType, gorpMigrationMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(row))
                vals = append(vals, queries.ValuesFromMapping(value, valMapping)...)</span>
        }

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, vals...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to insert all from gorpMigration slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by insertall for gorp_migrations")
        }</span>

        <span class="cov0" title="0">if len(gorpMigrationAfterInsertHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// InsertIgnoreAll inserts all rows with ignoring the existing ones having the same primary key values.
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o GorpMigrationSlice) InsertIgnoreAll(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.UpsertAll(ctx, exec, boil.None(), columns)
}</span>

// UpsertAll inserts or updates all rows
// Currently it doesn't support "NoContext" and "NoRowsAffected"
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o GorpMigrationSlice) UpsertAll(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Calculate the widest columns from all rows need to upsert
        <span class="cov0" title="0">insertCols := make(map[string]struct{}, 10)
        for _, row := range o </span><span class="cov0" title="0">{
                nzUniques := queries.NonZeroDefaultSet(mySQLGorpMigrationUniqueColumns, row)
                if len(nzUniques) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("cannot upsert with a table that cannot conflict on a unique column")
                }</span>
                <span class="cov0" title="0">insert, _ := insertColumns.InsertColumnSet(
                        gorpMigrationAllColumns,
                        gorpMigrationColumnsWithDefault,
                        gorpMigrationColumnsWithoutDefault,
                        queries.NonZeroDefaultSet(gorpMigrationColumnsWithDefault, row),
                )
                for _, col := range insert </span><span class="cov0" title="0">{
                        insertCols[col] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">insert := make([]string, 0, len(insertCols))
        for _, col := range gorpMigrationAllColumns </span><span class="cov0" title="0">{
                if _, ok := insertCols[col]; ok </span><span class="cov0" title="0">{
                        insert = append(insert, col)
                }</span>
        }

        <span class="cov0" title="0">update := updateColumns.UpdateColumnSet(
                gorpMigrationAllColumns,
                gorpMigrationPrimaryKeyColumns,
        )
        if !updateColumns.IsNone() &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: unable to upsert gorp_migrations, could not build update column list")
        }</span>

        <span class="cov0" title="0">buf := strmangle.GetBuffer()
        defer strmangle.PutBuffer(buf)

        if len(update) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(
                        buf,
                        "INSERT IGNORE INTO `gorp_migrations`(%s) VALUES %s",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, insert), ","),
                        strmangle.Placeholders(false, len(insert)*len(o), 1, len(insert)),
                )
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(
                        buf,
                        "INSERT INTO `gorp_migrations`(%s) VALUES %s ON DUPLICATE KEY UPDATE ",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, insert), ","),
                        strmangle.Placeholders(false, len(insert)*len(o), 1, len(insert)),
                )

                for i, v := range update </span><span class="cov0" title="0">{
                        if i != 0 </span><span class="cov0" title="0">{
                                buf.WriteByte(',')
                        }</span>
                        <span class="cov0" title="0">quoted := strmangle.IdentQuote(dialect.LQ, dialect.RQ, v)
                        buf.WriteString(quoted)
                        buf.WriteString(" = VALUES(")
                        buf.WriteString(quoted)
                        buf.WriteByte(')')</span>
                }
        }

        <span class="cov0" title="0">query := buf.String()
        valueMapping, err := queries.BindMapping(gorpMigrationType, gorpMigrationMapping, insert)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var vals []interface{}
        for _, row := range o </span><span class="cov0" title="0">{

                if err := row.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(row))
                vals = append(vals, queries.ValuesFromMapping(value, valueMapping)...)</span>
        }

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, query, vals...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to upsert for gorp_migrations")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by upsert for gorp_migrations")
        }</span>

        <span class="cov0" title="0">if len(gorpMigrationAfterUpsertHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAllByPage delete all GorpMigration records from the slice.
// This function deletes data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s GorpMigrationSlice) DeleteAllByPage(ctx context.Context, exec boil.ContextExecutor, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := DefaultPageSize
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt;= MaxPageSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.DeleteAll(ctx, exec)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].DeleteAll(ctx, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// UpdateAllByPage update all GorpMigration records from the slice.
// This function updates data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s GorpMigrationSlice) UpdateAllByPage(ctx context.Context, exec boil.ContextExecutor, cols M, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        // NOTE (eric): len(cols) should not be too big
        <span class="cov0" title="0">chunkSize := DefaultPageSize
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt;= MaxPageSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.UpdateAll(ctx, exec, cols)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].UpdateAll(ctx, exec, cols)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// InsertAllByPage insert all GorpMigration records from the slice.
// This function inserts data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s GorpMigrationSlice) InsertAllByPage(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;GorpMigrationColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.InsertAll(ctx, exec, columns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].InsertAll(ctx, exec, columns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// InsertIgnoreAllByPage insert all GorpMigration records from the slice.
// This function inserts data by pages to avoid exceeding Postgres limitation (max parameters: 65535)
func (s GorpMigrationSlice) InsertIgnoreAllByPage(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // max number of parameters = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;GorpMigrationColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.InsertIgnoreAll(ctx, exec, columns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].InsertIgnoreAll(ctx, exec, columns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// UpsertAllByPage upsert all GorpMigration records from the slice.
// This function upserts data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s GorpMigrationSlice) UpsertAllByPage(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;GorpMigrationColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.UpsertAll(ctx, exec, updateColumns, insertColumns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].UpsertAll(ctx, exec, updateColumns, insertColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

///////////////////////////////// END EXTENSIONS /////////////////////////////////
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "fmt"
        "strings"

        "github.com/volatiletech/sqlboiler/v4/drivers"
        "github.com/volatiletech/strmangle"
)

// buildUpsertQueryMySQL builds a SQL statement string using the upsertData provided.
func buildUpsertQueryMySQL(dia drivers.Dialect, tableName string, update, whitelist []string) string <span class="cov0" title="0">{
        whitelist = strmangle.IdentQuoteSlice(dia.LQ, dia.RQ, whitelist)
        tableName = strmangle.IdentQuote(dia.LQ, dia.RQ, tableName)

        buf := strmangle.GetBuffer()
        defer strmangle.PutBuffer(buf)

        var columns string
        if len(whitelist) != 0 </span><span class="cov0" title="0">{
                columns = strings.Join(whitelist, ",")
        }</span>

        <span class="cov0" title="0">if len(update) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(
                        buf,
                        "INSERT IGNORE INTO %s (%s) VALUES (%s)",
                        tableName,
                        columns,
                        strmangle.Placeholders(dia.UseIndexPlaceholders, len(whitelist), 1, 1),
                )
                return buf.String()
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(
                buf,
                "INSERT INTO %s (%s) VALUES (%s) ON DUPLICATE KEY UPDATE ",
                tableName,
                columns,
                strmangle.Placeholders(dia.UseIndexPlaceholders, len(whitelist), 1, 1),
        )

        for i, v := range update </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        buf.WriteByte(',')
                }</span>
                <span class="cov0" title="0">quoted := strmangle.IdentQuote(dia.LQ, dia.RQ, v)
                buf.WriteString(quoted)
                buf.WriteString(" = VALUES(")
                buf.WriteString(quoted)
                buf.WriteByte(')')</span>
        }

        <span class="cov0" title="0">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// Todo is an object representing the database table.
type Todo struct {
        ID        int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
        UserID    int64       `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
        Title     string      `boil:"title" json:"title" toml:"title" yaml:"title"`
        Content   null.String `boil:"content" json:"content,omitempty" toml:"content" yaml:"content,omitempty"`
        CreatedAt time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
        UpdatedAt time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

        R *todoR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L todoL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TodoColumns = struct {
        ID        string
        UserID    string
        Title     string
        Content   string
        CreatedAt string
        UpdatedAt string
}{
        ID:        "id",
        UserID:    "user_id",
        Title:     "title",
        Content:   "content",
        CreatedAt: "created_at",
        UpdatedAt: "updated_at",
}

var TodoTableColumns = struct {
        ID        string
        UserID    string
        Title     string
        Content   string
        CreatedAt string
        UpdatedAt string
}{
        ID:        "todos.id",
        UserID:    "todos.user_id",
        Title:     "todos.title",
        Content:   "todos.content",
        CreatedAt: "todos.created_at",
        UpdatedAt: "todos.updated_at",
}

// Generated where

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.EQ, x) }</span>
func (w whereHelperint64) NEQ(x int64) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.NEQ, x) }</span>
func (w whereHelperint64) LT(x int64) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LT, x) }</span>
func (w whereHelperint64) LTE(x int64) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LTE, x) }</span>
func (w whereHelperint64) GT(x int64) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GT, x) }</span>
func (w whereHelperint64) GTE(x int64) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GTE, x) }</span>
func (w whereHelperint64) IN(slice []int64) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, false, x)
}</span>
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.WhereNullEQ(w.field, true, x)
}</span>
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>
func (w whereHelpernull_String) LIKE(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qm.Where(w.field+" LIKE ?", x)
}</span>
func (w whereHelpernull_String) NLIKE(x null.String) qm.QueryMod <span class="cov0" title="0">{
        return qm.Where(w.field+" NOT LIKE ?", x)
}</span>
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    <span class="cov0" title="0">{ return qmhelper.WhereIsNull(w.field) }</span>
func (w whereHelpernull_String) IsNotNull() qm.QueryMod <span class="cov0" title="0">{ return qmhelper.WhereIsNotNull(w.field) }</span>

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.EQ, x)
}</span>
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.NEQ, x)
}</span>
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LT, x)
}</span>
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.LTE, x)
}</span>
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GT, x)
}</span>
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod <span class="cov0" title="0">{
        return qmhelper.Where(w.field, qmhelper.GTE, x)
}</span>

var TodoWhere = struct {
        ID        whereHelperint64
        UserID    whereHelperint64
        Title     whereHelperstring
        Content   whereHelpernull_String
        CreatedAt whereHelpertime_Time
        UpdatedAt whereHelpertime_Time
}{
        ID:        whereHelperint64{field: "`todos`.`id`"},
        UserID:    whereHelperint64{field: "`todos`.`user_id`"},
        Title:     whereHelperstring{field: "`todos`.`title`"},
        Content:   whereHelpernull_String{field: "`todos`.`content`"},
        CreatedAt: whereHelpertime_Time{field: "`todos`.`created_at`"},
        UpdatedAt: whereHelpertime_Time{field: "`todos`.`updated_at`"},
}

// TodoRels is where relationship names are stored.
var TodoRels = struct {
}{}

// todoR is where relationships are stored.
type todoR struct {
}

// NewStruct creates a new relationship struct
func (*todoR) NewStruct() *todoR <span class="cov0" title="0">{
        return &amp;todoR{}
}</span>

// todoL is where Load methods for each relationship are stored.
type todoL struct{}

var (
        todoAllColumns            = []string{"id", "user_id", "title", "content", "created_at", "updated_at"}
        todoColumnsWithoutDefault = []string{"user_id", "title", "content", "created_at", "updated_at"}
        todoColumnsWithDefault    = []string{"id"}
        todoPrimaryKeyColumns     = []string{"id"}
        todoGeneratedColumns      = []string{}
)

type (
        // TodoSlice is an alias for a slice of pointers to Todo.
        // This should almost always be used instead of []Todo.
        TodoSlice []*Todo
        // TodoHook is the signature for custom Todo hook methods
        TodoHook func(context.Context, boil.ContextExecutor, *Todo) error

        todoQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        todoType                 = reflect.TypeOf(&amp;Todo{})
        todoMapping              = queries.MakeStructMapping(todoType)
        todoPrimaryKeyMapping, _ = queries.BindMapping(todoType, todoMapping, todoPrimaryKeyColumns)
        todoInsertCacheMut       sync.RWMutex
        todoInsertCache          = make(map[string]insertCache)
        todoUpdateCacheMut       sync.RWMutex
        todoUpdateCache          = make(map[string]updateCache)
        todoUpsertCacheMut       sync.RWMutex
        todoUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var todoAfterSelectMu sync.Mutex
var todoAfterSelectHooks []TodoHook

var todoBeforeInsertMu sync.Mutex
var todoBeforeInsertHooks []TodoHook
var todoAfterInsertMu sync.Mutex
var todoAfterInsertHooks []TodoHook

var todoBeforeUpdateMu sync.Mutex
var todoBeforeUpdateHooks []TodoHook
var todoAfterUpdateMu sync.Mutex
var todoAfterUpdateHooks []TodoHook

var todoBeforeDeleteMu sync.Mutex
var todoBeforeDeleteHooks []TodoHook
var todoAfterDeleteMu sync.Mutex
var todoAfterDeleteHooks []TodoHook

var todoBeforeUpsertMu sync.Mutex
var todoBeforeUpsertHooks []TodoHook
var todoAfterUpsertMu sync.Mutex
var todoAfterUpsertHooks []TodoHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Todo) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoAfterSelectHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Todo) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoBeforeInsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Todo) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoAfterInsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Todo) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoBeforeUpdateHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Todo) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoAfterUpdateHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Todo) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoBeforeDeleteHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Todo) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range todoAfterDeleteHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Todo) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range todoBeforeUpsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Todo) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range todoAfterUpsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AddTodoHook registers your hook function for all future operations.
func AddTodoHook(hookPoint boil.HookPoint, todoHook TodoHook) <span class="cov0" title="0">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov0" title="0">
                todoAfterSelectMu.Lock()
                todoAfterSelectHooks = append(todoAfterSelectHooks, todoHook)
                todoAfterSelectMu.Unlock()</span>
        case boil.BeforeInsertHook:<span class="cov0" title="0">
                todoBeforeInsertMu.Lock()
                todoBeforeInsertHooks = append(todoBeforeInsertHooks, todoHook)
                todoBeforeInsertMu.Unlock()</span>
        case boil.AfterInsertHook:<span class="cov0" title="0">
                todoAfterInsertMu.Lock()
                todoAfterInsertHooks = append(todoAfterInsertHooks, todoHook)
                todoAfterInsertMu.Unlock()</span>
        case boil.BeforeUpdateHook:<span class="cov0" title="0">
                todoBeforeUpdateMu.Lock()
                todoBeforeUpdateHooks = append(todoBeforeUpdateHooks, todoHook)
                todoBeforeUpdateMu.Unlock()</span>
        case boil.AfterUpdateHook:<span class="cov0" title="0">
                todoAfterUpdateMu.Lock()
                todoAfterUpdateHooks = append(todoAfterUpdateHooks, todoHook)
                todoAfterUpdateMu.Unlock()</span>
        case boil.BeforeDeleteHook:<span class="cov0" title="0">
                todoBeforeDeleteMu.Lock()
                todoBeforeDeleteHooks = append(todoBeforeDeleteHooks, todoHook)
                todoBeforeDeleteMu.Unlock()</span>
        case boil.AfterDeleteHook:<span class="cov0" title="0">
                todoAfterDeleteMu.Lock()
                todoAfterDeleteHooks = append(todoAfterDeleteHooks, todoHook)
                todoAfterDeleteMu.Unlock()</span>
        case boil.BeforeUpsertHook:<span class="cov0" title="0">
                todoBeforeUpsertMu.Lock()
                todoBeforeUpsertHooks = append(todoBeforeUpsertHooks, todoHook)
                todoBeforeUpsertMu.Unlock()</span>
        case boil.AfterUpsertHook:<span class="cov0" title="0">
                todoAfterUpsertMu.Lock()
                todoAfterUpsertHooks = append(todoAfterUpsertHooks, todoHook)
                todoAfterUpsertMu.Unlock()</span>
        }
}

// One returns a single todo record from the query.
func (q todoQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Todo, error) <span class="cov8" title="1">{
        o := &amp;Todo{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for todos")</span>
        }

        <span class="cov8" title="1">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

// All returns all Todo records from the query.
func (q todoQuery) All(ctx context.Context, exec boil.ContextExecutor) (TodoSlice, error) <span class="cov8" title="1">{
        var o []*Todo

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to Todo slice")
        }</span>

        <span class="cov8" title="1">if len(todoAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return o, nil</span>
}

// Count returns the count of all Todo records in the query.
func (q todoQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count todos rows")
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// Exists checks if the row exists in the table.
func (q todoQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov8" title="1">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if todos exists")
        }</span>

        <span class="cov8" title="1">return count &gt; 0, nil</span>
}

// Todos retrieves all the records using an executor.
func Todos(mods ...qm.QueryMod) todoQuery <span class="cov8" title="1">{
        mods = append(mods, qm.From("`todos`"))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov8" title="1">{
                queries.SetSelect(q, []string{"`todos`.*"})
        }</span>

        <span class="cov8" title="1">return todoQuery{q}</span>
}

// FindTodo retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTodo(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Todo, error) <span class="cov8" title="1">{
        todoObj := &amp;Todo{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(
                "select %s from `todos` where `id`=?", sel,
        )

        q := queries.Raw(query, iD)

        err := q.Bind(ctx, exec, todoObj)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from todos")</span>
        }

        <span class="cov8" title="1">if err = todoObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return todoObj, err
        }</span>

        <span class="cov8" title="1">return todoObj, nil</span>
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Todo) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no todos provided for insertion")
        }</span>

        <span class="cov8" title="1">var err error
        if !boil.TimestampsAreSkipped(ctx) </span><span class="cov8" title="1">{
                currTime := time.Now().In(boil.GetLocation())

                if o.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                        o.CreatedAt = currTime
                }</span>
                <span class="cov8" title="1">if o.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                        o.UpdatedAt = currTime
                }</span>
        }

        <span class="cov8" title="1">if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(todoColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        todoInsertCacheMut.RLock()
        cache, cached := todoInsertCache[key]
        todoInsertCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl, returnColumns := columns.InsertColumnSet(
                        todoAllColumns,
                        todoColumnsWithDefault,
                        todoColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(todoType, todoMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cache.retMapping, err = queries.BindMapping(todoType, todoMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(wl) != 0 </span><span class="cov8" title="1">{
                        cache.query = fmt.Sprintf("INSERT INTO `todos` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO `todos` () VALUES ()%s%s"
                }</span>

                <span class="cov8" title="1">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                        cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `todos` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, todoPrimaryKeyColumns))
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, cache.query, vals...)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into todos")
        }</span>

        <span class="cov8" title="1">var lastID int64
        var identifierCols []interface{}

        if len(cache.retMapping) == 0 </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov8" title="1">lastID, err = result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return ErrSyncFail
        }</span>

        <span class="cov8" title="1">o.ID = int64(lastID)
        if lastID != 0 &amp;&amp; len(cache.retMapping) == 1 &amp;&amp; cache.retMapping[0] == todoMapping["id"] </span><span class="cov8" title="1">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">identifierCols = []interface{}{
                o.ID,
        }

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.retQuery)
                fmt.Fprintln(writer, identifierCols...)
        }</span>
        <span class="cov0" title="0">err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to populate default values for todos")
        }</span>

CacheNoHooks:
        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                todoInsertCacheMut.Lock()
                todoInsertCache[key] = cache
                todoInsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterInsertHooks(ctx, exec)</span>
}

// Update uses an executor to update the Todo.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Todo) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov8" title="1">{
        if !boil.TimestampsAreSkipped(ctx) </span><span class="cov8" title="1">{
                currTime := time.Now().In(boil.GetLocation())

                o.UpdatedAt = currTime
        }</span>

        <span class="cov8" title="1">var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">key := makeCacheKey(columns, nil)
        todoUpdateCacheMut.RLock()
        cache, cached := todoUpdateCache[key]
        todoUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl := columns.UpdateColumnSet(
                        todoAllColumns,
                        todoPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov8" title="1">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov8" title="1">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update todos, could not build whitelist")
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf("UPDATE `todos` SET %s WHERE %s",
                        strmangle.SetParamNames("`", "`", 0, wl),
                        strmangle.WhereClause("`", "`", 0, todoPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(todoType, todoMapping, append(wl, todoPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update todos row")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for todos")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                todoUpdateCacheMut.Lock()
                todoUpdateCache[key] = cache
                todoUpdateCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAll updates all rows with the specified column values.
func (q todoQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for todos")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for todos")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TodoSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov0" title="0">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov0" title="0">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov0" title="0">for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), todoPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := fmt.Sprintf("UPDATE `todos` SET %s WHERE %s",
                strmangle.SetParamNames("`", "`", 0, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, todoPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in todo slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all todo")
        }</span>
        <span class="cov0" title="0">return rowsAff, nil</span>
}

var mySQLTodoUniqueColumns = []string{
        "id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Todo) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no todos provided for upsert")
        }</span>
        <span class="cov0" title="0">if !boil.TimestampsAreSkipped(ctx) </span><span class="cov0" title="0">{
                currTime := time.Now().In(boil.GetLocation())

                if o.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        o.CreatedAt = currTime
                }</span>
                <span class="cov0" title="0">o.UpdatedAt = currTime</span>
        }

        <span class="cov0" title="0">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nzDefaults := queries.NonZeroDefaultSet(todoColumnsWithDefault, o)
        nzUniques := queries.NonZeroDefaultSet(mySQLTodoUniqueColumns, o)

        if len(nzUniques) == 0 </span><span class="cov0" title="0">{
                return errors.New("cannot upsert with a table that cannot conflict on a unique column")
        }</span>

        // Build cache key in-line uglily - mysql vs psql problems
        <span class="cov0" title="0">buf := strmangle.GetBuffer()
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzUniques </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">key := buf.String()
        strmangle.PutBuffer(buf)

        todoUpsertCacheMut.RLock()
        cache, cached := todoUpsertCache[key]
        todoUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov0" title="0">{
                insert, _ := insertColumns.InsertColumnSet(
                        todoAllColumns,
                        todoColumnsWithDefault,
                        todoColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        todoAllColumns,
                        todoPrimaryKeyColumns,
                )

                if !updateColumns.IsNone() &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert todos, could not build update column list")
                }</span>

                <span class="cov0" title="0">ret := strmangle.SetComplement(todoAllColumns, strmangle.SetIntersect(insert, update))

                cache.query = buildUpsertQueryMySQL(dialect, "`todos`", update, insert)
                cache.retQuery = fmt.Sprintf(
                        "SELECT %s FROM `todos` WHERE %s",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
                        strmangle.WhereClause("`", "`", 0, nzUniques),
                )

                cache.valueMapping, err = queries.BindMapping(todoType, todoMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(ret) != 0 </span><span class="cov0" title="0">{
                        cache.retMapping, err = queries.BindMapping(todoType, todoMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, cache.query, vals...)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert for todos")
        }</span>

        <span class="cov0" title="0">var lastID int64
        var uniqueMap []uint64
        var nzUniqueCols []interface{}

        if len(cache.retMapping) == 0 </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">lastID, err = result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return ErrSyncFail
        }</span>

        <span class="cov0" title="0">o.ID = int64(lastID)
        if lastID != 0 &amp;&amp; len(cache.retMapping) == 1 &amp;&amp; cache.retMapping[0] == todoMapping["id"] </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">uniqueMap, err = queries.BindMapping(todoType, todoMapping, nzUniques)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to retrieve unique values for todos")
        }</span>
        <span class="cov0" title="0">nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.retQuery)
                fmt.Fprintln(writer, nzUniqueCols...)
        }</span>
        <span class="cov0" title="0">err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to populate default values for todos")
        }</span>

CacheNoHooks:
        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                todoUpsertCacheMut.Lock()
                todoUpsertCache[key] = cache
                todoUpsertCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// Delete deletes a single Todo record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Todo) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no Todo provided for delete")
        }</span>

        <span class="cov8" title="1">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), todoPrimaryKeyMapping)
        sql := "DELETE FROM `todos` WHERE `id`=?"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from todos")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for todos")
        }</span>

        <span class="cov8" title="1">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// DeleteAll deletes all matching rows.
func (q todoQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no todoQuery provided for delete all")
        }</span>

        <span class="cov0" title="0">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from todos")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for todos")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TodoSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(todoBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">var args []interface{}
        for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), todoPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := "DELETE FROM `todos` WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, todoPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from todo slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for todos")
        }</span>

        <span class="cov0" title="0">if len(todoAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Todo) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        ret, err := FindTodo(ctx, exec, o.ID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">*o = *ret
        return nil</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TodoSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov0" title="0">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">slice := TodoSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), todoPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := "SELECT `todos`.* FROM `todos` WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, todoPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in TodoSlice")
        }</span>

        <span class="cov0" title="0">*o = slice

        return nil</span>
}

// TodoExists checks if the Todo row exists.
func TodoExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) <span class="cov0" title="0">{
        var exists bool
        sql := "select exists(select 1 from `todos` where `id`=? limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, iD)
        }</span>
        <span class="cov0" title="0">row := exec.QueryRowContext(ctx, sql, iD)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if todos exists")
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// Exists checks if the Todo row exists.
func (o *Todo) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return TodoExists(ctx, exec, o.ID)
}</span>

// /////////////////////////////// BEGIN EXTENSIONS /////////////////////////////////
// Expose table columns
var (
        TodoAllColumns            = todoAllColumns
        TodoColumnsWithoutDefault = todoColumnsWithoutDefault
        TodoColumnsWithDefault    = todoColumnsWithDefault
        TodoPrimaryKeyColumns     = todoPrimaryKeyColumns
        TodoGeneratedColumns      = todoGeneratedColumns
)

// GetID get ID from model object
func (o *Todo) GetID() int64 <span class="cov0" title="0">{
        return o.ID
}</span>

// GetIDs extract IDs from model objects
func (s TodoSlice) GetIDs() []int64 <span class="cov0" title="0">{
        result := make([]int64, len(s))
        for i := range s </span><span class="cov0" title="0">{
                result[i] = s[i].ID
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetIntfIDs extract IDs from model objects as interface slice
func (s TodoSlice) GetIntfIDs() []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, len(s))
        for i := range s </span><span class="cov0" title="0">{
                result[i] = s[i].ID
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToIDMap convert a slice of model objects to a map with ID as key
func (s TodoSlice) ToIDMap() map[int64]*Todo <span class="cov0" title="0">{
        result := make(map[int64]*Todo, len(s))
        for _, o := range s </span><span class="cov0" title="0">{
                result[o.ID] = o
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToUniqueItems construct a slice of unique items from the given slice
func (s TodoSlice) ToUniqueItems() TodoSlice <span class="cov0" title="0">{
        result := make(TodoSlice, 0, len(s))
        mapChk := make(map[int64]struct{}, len(s))
        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                o := s[i]
                if _, ok := mapChk[o.ID]; !ok </span><span class="cov0" title="0">{
                        mapChk[o.ID] = struct{}{}
                        result = append(result, o)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// FindItemByID find item by ID in the slice
func (s TodoSlice) FindItemByID(id int64) *Todo <span class="cov0" title="0">{
        for _, o := range s </span><span class="cov0" title="0">{
                if o.ID == id </span><span class="cov0" title="0">{
                        return o
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindMissingItemIDs find all item IDs that are not in the list
// NOTE: the input ID slice should contain unique values
func (s TodoSlice) FindMissingItemIDs(expectedIDs []int64) []int64 <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return expectedIDs
        }</span>
        <span class="cov0" title="0">result := []int64{}
        mapChk := s.ToIDMap()
        for _, id := range expectedIDs </span><span class="cov0" title="0">{
                if _, ok := mapChk[id]; !ok </span><span class="cov0" title="0">{
                        result = append(result, id)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// InsertAll inserts all rows with the specified column values, using an executor.
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o TodoSlice) InsertAll(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov8" title="1">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Calculate the widest columns from all rows need to insert
        <span class="cov8" title="1">wlCols := make(map[string]struct{}, 10)
        for _, row := range o </span><span class="cov8" title="1">{
                wl, _ := columns.InsertColumnSet(
                        todoAllColumns,
                        todoColumnsWithDefault,
                        todoColumnsWithoutDefault,
                        queries.NonZeroDefaultSet(todoColumnsWithDefault, row),
                )
                for _, col := range wl </span><span class="cov8" title="1">{
                        wlCols[col] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">wl := make([]string, 0, len(wlCols))
        for _, col := range todoAllColumns </span><span class="cov8" title="1">{
                if _, ok := wlCols[col]; ok </span><span class="cov8" title="1">{
                        wl = append(wl, col)
                }</span>
        }

        <span class="cov8" title="1">var sql string
        vals := []interface{}{}
        for i, row := range o </span><span class="cov8" title="1">{
                if !boil.TimestampsAreSkipped(ctx) </span><span class="cov8" title="1">{
                        currTime := time.Now().In(boil.GetLocation())
                        if row.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                                row.CreatedAt = currTime
                        }</span>
                        <span class="cov8" title="1">if row.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                                row.UpdatedAt = currTime
                        }</span>
                }

                <span class="cov8" title="1">if err := row.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        sql = "INSERT INTO `todos` " + "(`" + strings.Join(wl, "`,`") + "`)" + " VALUES "
                }</span>
                <span class="cov8" title="1">sql += strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), len(vals)+1, len(wl))
                if i != len(o)-1 </span><span class="cov8" title="1">{
                        sql += ","
                }</span>
                <span class="cov8" title="1">valMapping, err := queries.BindMapping(todoType, todoMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(row))
                vals = append(vals, queries.ValuesFromMapping(value, valMapping)...)</span>
        }

        <span class="cov8" title="1">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, sql, vals...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to insert all from todo slice")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by insertall for todos")
        }</span>

        <span class="cov8" title="1">if len(todoAfterInsertHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return rowsAff, nil</span>
}

// InsertIgnoreAll inserts all rows with ignoring the existing ones having the same primary key values.
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o TodoSlice) InsertIgnoreAll(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.UpsertAll(ctx, exec, boil.None(), columns)
}</span>

// UpsertAll inserts or updates all rows
// Currently it doesn't support "NoContext" and "NoRowsAffected"
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o TodoSlice) UpsertAll(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Calculate the widest columns from all rows need to upsert
        <span class="cov0" title="0">insertCols := make(map[string]struct{}, 10)
        for _, row := range o </span><span class="cov0" title="0">{
                nzUniques := queries.NonZeroDefaultSet(mySQLTodoUniqueColumns, row)
                if len(nzUniques) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("cannot upsert with a table that cannot conflict on a unique column")
                }</span>
                <span class="cov0" title="0">insert, _ := insertColumns.InsertColumnSet(
                        todoAllColumns,
                        todoColumnsWithDefault,
                        todoColumnsWithoutDefault,
                        queries.NonZeroDefaultSet(todoColumnsWithDefault, row),
                )
                for _, col := range insert </span><span class="cov0" title="0">{
                        insertCols[col] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">insert := make([]string, 0, len(insertCols))
        for _, col := range todoAllColumns </span><span class="cov0" title="0">{
                if _, ok := insertCols[col]; ok </span><span class="cov0" title="0">{
                        insert = append(insert, col)
                }</span>
        }

        <span class="cov0" title="0">update := updateColumns.UpdateColumnSet(
                todoAllColumns,
                todoPrimaryKeyColumns,
        )
        if !updateColumns.IsNone() &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: unable to upsert todos, could not build update column list")
        }</span>

        <span class="cov0" title="0">buf := strmangle.GetBuffer()
        defer strmangle.PutBuffer(buf)

        if len(update) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(
                        buf,
                        "INSERT IGNORE INTO `todos`(%s) VALUES %s",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, insert), ","),
                        strmangle.Placeholders(false, len(insert)*len(o), 1, len(insert)),
                )
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(
                        buf,
                        "INSERT INTO `todos`(%s) VALUES %s ON DUPLICATE KEY UPDATE ",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, insert), ","),
                        strmangle.Placeholders(false, len(insert)*len(o), 1, len(insert)),
                )

                for i, v := range update </span><span class="cov0" title="0">{
                        if i != 0 </span><span class="cov0" title="0">{
                                buf.WriteByte(',')
                        }</span>
                        <span class="cov0" title="0">quoted := strmangle.IdentQuote(dialect.LQ, dialect.RQ, v)
                        buf.WriteString(quoted)
                        buf.WriteString(" = VALUES(")
                        buf.WriteString(quoted)
                        buf.WriteByte(')')</span>
                }
        }

        <span class="cov0" title="0">query := buf.String()
        valueMapping, err := queries.BindMapping(todoType, todoMapping, insert)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var vals []interface{}
        for _, row := range o </span><span class="cov0" title="0">{
                if !boil.TimestampsAreSkipped(ctx) </span><span class="cov0" title="0">{
                        currTime := time.Now().In(boil.GetLocation())
                        if row.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                                row.CreatedAt = currTime
                        }</span>

                        <span class="cov0" title="0">row.UpdatedAt = currTime</span>
                }

                <span class="cov0" title="0">if err := row.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(row))
                vals = append(vals, queries.ValuesFromMapping(value, valueMapping)...)</span>
        }

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, query, vals...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to upsert for todos")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by upsert for todos")
        }</span>

        <span class="cov0" title="0">if len(todoAfterUpsertHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAllByPage delete all Todo records from the slice.
// This function deletes data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s TodoSlice) DeleteAllByPage(ctx context.Context, exec boil.ContextExecutor, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := DefaultPageSize
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt;= MaxPageSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.DeleteAll(ctx, exec)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].DeleteAll(ctx, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// UpdateAllByPage update all Todo records from the slice.
// This function updates data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s TodoSlice) UpdateAllByPage(ctx context.Context, exec boil.ContextExecutor, cols M, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        // NOTE (eric): len(cols) should not be too big
        <span class="cov0" title="0">chunkSize := DefaultPageSize
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt;= MaxPageSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.UpdateAll(ctx, exec, cols)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].UpdateAll(ctx, exec, cols)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// InsertAllByPage insert all Todo records from the slice.
// This function inserts data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s TodoSlice) InsertAllByPage(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;TodoColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.InsertAll(ctx, exec, columns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].InsertAll(ctx, exec, columns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// InsertIgnoreAllByPage insert all Todo records from the slice.
// This function inserts data by pages to avoid exceeding Postgres limitation (max parameters: 65535)
func (s TodoSlice) InsertIgnoreAllByPage(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // max number of parameters = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;TodoColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.InsertIgnoreAll(ctx, exec, columns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].InsertIgnoreAll(ctx, exec, columns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// UpsertAllByPage upsert all Todo records from the slice.
// This function upserts data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s TodoSlice) UpsertAllByPage(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;TodoColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.UpsertAll(ctx, exec, updateColumns, insertColumns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].UpsertAll(ctx, exec, updateColumns, insertColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

///////////////////////////////// END EXTENSIONS /////////////////////////////////
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/friendsofgo/errors"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
        "github.com/volatiletech/strmangle"
)

// User is an object representing the database table.
type User struct {
        ID                  int       `boil:"id" json:"id" toml:"id" yaml:"id"`
        FirstName           string    `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
        LastName            string    `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
        Email               string    `boil:"email" json:"email" toml:"email" yaml:"email"`
        Password            string    `boil:"password" json:"password" toml:"password" yaml:"password"`
        Birthday            null.Time `boil:"birthday" json:"birthday,omitempty" toml:"birthday" yaml:"birthday,omitempty"`
        FrontIdentification string    `boil:"front_identification" json:"front_identification" toml:"front_identification" yaml:"front_identification"`
        BackIdentification  string    `boil:"back_identification" json:"back_identification" toml:"back_identification" yaml:"back_identification"`
        CreatedAt           time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
        UpdatedAt           time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

        R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
        L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
        ID                  string
        FirstName           string
        LastName            string
        Email               string
        Password            string
        Birthday            string
        FrontIdentification string
        BackIdentification  string
        CreatedAt           string
        UpdatedAt           string
}{
        ID:                  "id",
        FirstName:           "first_name",
        LastName:            "last_name",
        Email:               "email",
        Password:            "password",
        Birthday:            "birthday",
        FrontIdentification: "front_identification",
        BackIdentification:  "back_identification",
        CreatedAt:           "created_at",
        UpdatedAt:           "updated_at",
}

var UserTableColumns = struct {
        ID                  string
        FirstName           string
        LastName            string
        Email               string
        Password            string
        Birthday            string
        FrontIdentification string
        BackIdentification  string
        CreatedAt           string
        UpdatedAt           string
}{
        ID:                  "users.id",
        FirstName:           "users.first_name",
        LastName:            "users.last_name",
        Email:               "users.email",
        Password:            "users.password",
        Birthday:            "users.birthday",
        FrontIdentification: "users.front_identification",
        BackIdentification:  "users.back_identification",
        CreatedAt:           "users.created_at",
        UpdatedAt:           "users.updated_at",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.EQ, x) }</span>
func (w whereHelperint) NEQ(x int) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.NEQ, x) }</span>
func (w whereHelperint) LT(x int) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LT, x) }</span>
func (w whereHelperint) LTE(x int) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.LTE, x) }</span>
func (w whereHelperint) GT(x int) qm.QueryMod  <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GT, x) }</span>
func (w whereHelperint) GTE(x int) qm.QueryMod <span class="cov0" title="0">{ return qmhelper.Where(w.field, qmhelper.GTE, x) }</span>
func (w whereHelperint) IN(slice []int) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)</span>
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod <span class="cov0" title="0">{
        values := make([]interface{}, 0, len(slice))
        for _, value := range slice </span><span class="cov0" title="0">{
                values = append(values, value)
        }</span>
        <span class="cov0" title="0">return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)</span>
}

var UserWhere = struct {
        ID                  whereHelperint
        FirstName           whereHelperstring
        LastName            whereHelperstring
        Email               whereHelperstring
        Password            whereHelperstring
        Birthday            whereHelpernull_Time
        FrontIdentification whereHelperstring
        BackIdentification  whereHelperstring
        CreatedAt           whereHelpertime_Time
        UpdatedAt           whereHelpertime_Time
}{
        ID:                  whereHelperint{field: "`users`.`id`"},
        FirstName:           whereHelperstring{field: "`users`.`first_name`"},
        LastName:            whereHelperstring{field: "`users`.`last_name`"},
        Email:               whereHelperstring{field: "`users`.`email`"},
        Password:            whereHelperstring{field: "`users`.`password`"},
        Birthday:            whereHelpernull_Time{field: "`users`.`birthday`"},
        FrontIdentification: whereHelperstring{field: "`users`.`front_identification`"},
        BackIdentification:  whereHelperstring{field: "`users`.`back_identification`"},
        CreatedAt:           whereHelpertime_Time{field: "`users`.`created_at`"},
        UpdatedAt:           whereHelpertime_Time{field: "`users`.`updated_at`"},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
}{}

// userR is where relationships are stored.
type userR struct {
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR <span class="cov0" title="0">{
        return &amp;userR{}
}</span>

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
        userAllColumns            = []string{"id", "first_name", "last_name", "email", "password", "birthday", "front_identification", "back_identification", "created_at", "updated_at"}
        userColumnsWithoutDefault = []string{"first_name", "last_name", "email", "password", "birthday", "front_identification", "back_identification", "created_at", "updated_at"}
        userColumnsWithDefault    = []string{"id"}
        userPrimaryKeyColumns     = []string{"id"}
        userGeneratedColumns      = []string{}
)

type (
        // UserSlice is an alias for a slice of pointers to User.
        // This should almost always be used instead of []User.
        UserSlice []*User
        // UserHook is the signature for custom User hook methods
        UserHook func(context.Context, boil.ContextExecutor, *User) error

        userQuery struct {
                *queries.Query
        }
)

// Cache for insert, update and upsert
var (
        userType                 = reflect.TypeOf(&amp;User{})
        userMapping              = queries.MakeStructMapping(userType)
        userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
        userInsertCacheMut       sync.RWMutex
        userInsertCache          = make(map[string]insertCache)
        userUpdateCacheMut       sync.RWMutex
        userUpdateCache          = make(map[string]updateCache)
        userUpsertCacheMut       sync.RWMutex
        userUpsertCache          = make(map[string]insertCache)
)

var (
        // Force time package dependency for automated UpdatedAt/CreatedAt.
        _ = time.Second
        // Force qmhelper dependency for where clause generation (which doesn't
        // always happen)
        _ = qmhelper.Where
)

var userAfterSelectMu sync.Mutex
var userAfterSelectHooks []UserHook

var userBeforeInsertMu sync.Mutex
var userBeforeInsertHooks []UserHook
var userAfterInsertMu sync.Mutex
var userAfterInsertHooks []UserHook

var userBeforeUpdateMu sync.Mutex
var userBeforeUpdateHooks []UserHook
var userAfterUpdateMu sync.Mutex
var userAfterUpdateHooks []UserHook

var userBeforeDeleteMu sync.Mutex
var userBeforeDeleteHooks []UserHook
var userAfterDeleteMu sync.Mutex
var userAfterDeleteHooks []UserHook

var userBeforeUpsertMu sync.Mutex
var userBeforeUpsertHooks []UserHook
var userAfterUpsertMu sync.Mutex
var userAfterUpsertHooks []UserHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range userAfterSelectHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range userBeforeInsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range userAfterInsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range userBeforeUpdateHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov8" title="1">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hook := range userAfterUpdateHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range userBeforeDeleteHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range userAfterDeleteHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range userBeforeUpsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) <span class="cov0" title="0">{
        if boil.HooksAreSkipped(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, hook := range userAfterUpsertHooks </span><span class="cov0" title="0">{
                if err := hook(ctx, exec, o); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) <span class="cov0" title="0">{
        switch hookPoint </span>{
        case boil.AfterSelectHook:<span class="cov0" title="0">
                userAfterSelectMu.Lock()
                userAfterSelectHooks = append(userAfterSelectHooks, userHook)
                userAfterSelectMu.Unlock()</span>
        case boil.BeforeInsertHook:<span class="cov0" title="0">
                userBeforeInsertMu.Lock()
                userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
                userBeforeInsertMu.Unlock()</span>
        case boil.AfterInsertHook:<span class="cov0" title="0">
                userAfterInsertMu.Lock()
                userAfterInsertHooks = append(userAfterInsertHooks, userHook)
                userAfterInsertMu.Unlock()</span>
        case boil.BeforeUpdateHook:<span class="cov0" title="0">
                userBeforeUpdateMu.Lock()
                userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
                userBeforeUpdateMu.Unlock()</span>
        case boil.AfterUpdateHook:<span class="cov0" title="0">
                userAfterUpdateMu.Lock()
                userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
                userAfterUpdateMu.Unlock()</span>
        case boil.BeforeDeleteHook:<span class="cov0" title="0">
                userBeforeDeleteMu.Lock()
                userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
                userBeforeDeleteMu.Unlock()</span>
        case boil.AfterDeleteHook:<span class="cov0" title="0">
                userAfterDeleteMu.Lock()
                userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
                userAfterDeleteMu.Unlock()</span>
        case boil.BeforeUpsertHook:<span class="cov0" title="0">
                userBeforeUpsertMu.Lock()
                userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
                userBeforeUpsertMu.Unlock()</span>
        case boil.AfterUpsertHook:<span class="cov0" title="0">
                userAfterUpsertMu.Lock()
                userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
                userAfterUpsertMu.Unlock()</span>
        }
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) <span class="cov8" title="1">{
        o := &amp;User{}

        queries.SetLimit(q.Query, 1)

        err := q.Bind(ctx, exec, o)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: failed to execute a one query for users")</span>
        }

        <span class="cov8" title="1">if err := o.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return o, err
        }</span>

        <span class="cov8" title="1">return o, nil</span>
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) <span class="cov0" title="0">{
        var o []*User

        err := q.Bind(ctx, exec, &amp;o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "models: failed to assign all query results to User slice")
        }</span>

        <span class="cov0" title="0">if len(userAfterSelectHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return o, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return o, nil</span>
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to count users rows")
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        var count int64

        queries.SetSelect(q.Query, nil)
        queries.SetCount(q.Query)
        queries.SetLimit(q.Query, 1)

        err := q.Query.QueryRowContext(ctx, exec).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: failed to check if users exists")
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery <span class="cov8" title="1">{
        mods = append(mods, qm.From("`users`"))
        q := NewQuery(mods...)
        if len(queries.GetSelect(q)) == 0 </span><span class="cov8" title="1">{
                queries.SetSelect(q, []string{"`users`.*"})
        }</span>

        <span class="cov8" title="1">return userQuery{q}</span>
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*User, error) <span class="cov8" title="1">{
        userObj := &amp;User{}

        sel := "*"
        if len(selectCols) &gt; 0 </span><span class="cov0" title="0">{
                sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
        }</span>
        <span class="cov8" title="1">query := fmt.Sprintf(
                "select %s from `users` where `id`=?", sel,
        )

        q := queries.Raw(query, iD)

        err := q.Bind(ctx, exec, userObj)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "models: unable to select from users")</span>
        }

        <span class="cov8" title="1">if err = userObj.doAfterSelectHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return userObj, err
        }</span>

        <span class="cov8" title="1">return userObj, nil</span>
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no users provided for insertion")
        }</span>

        <span class="cov8" title="1">var err error
        if !boil.TimestampsAreSkipped(ctx) </span><span class="cov8" title="1">{
                currTime := time.Now().In(boil.GetLocation())

                if o.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                        o.CreatedAt = currTime
                }</span>
                <span class="cov8" title="1">if o.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                        o.UpdatedAt = currTime
                }</span>
        }

        <span class="cov8" title="1">if err := o.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

        key := makeCacheKey(columns, nzDefaults)
        userInsertCacheMut.RLock()
        cache, cached := userInsertCache[key]
        userInsertCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl, returnColumns := columns.InsertColumnSet(
                        userAllColumns,
                        userColumnsWithDefault,
                        userColumnsWithoutDefault,
                        nzDefaults,
                )

                cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(wl) != 0 </span><span class="cov8" title="1">{
                        cache.query = fmt.Sprintf("INSERT INTO `users` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
                }</span> else<span class="cov0" title="0"> {
                        cache.query = "INSERT INTO `users` () VALUES ()%s%s"
                }</span>

                <span class="cov8" title="1">var queryOutput, queryReturning string

                if len(cache.retMapping) != 0 </span><span class="cov8" title="1">{
                        cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `users` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns))
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)</span>
        }

        <span class="cov8" title="1">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov8" title="1">result, err := exec.ExecContext(ctx, cache.query, vals...)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to insert into users")
        }</span>

        <span class="cov8" title="1">var lastID int64
        var identifierCols []interface{}

        if len(cache.retMapping) == 0 </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov8" title="1">lastID, err = result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return ErrSyncFail
        }</span>

        <span class="cov8" title="1">o.ID = int(lastID)
        if lastID != 0 &amp;&amp; len(cache.retMapping) == 1 &amp;&amp; cache.retMapping[0] == userMapping["id"] </span><span class="cov8" title="1">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">identifierCols = []interface{}{
                o.ID,
        }

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.retQuery)
                fmt.Fprintln(writer, identifierCols...)
        }</span>
        <span class="cov0" title="0">err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to populate default values for users")
        }</span>

CacheNoHooks:
        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                userInsertCacheMut.Lock()
                userInsertCache[key] = cache
                userInsertCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return o.doAfterInsertHooks(ctx, exec)</span>
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov8" title="1">{
        if !boil.TimestampsAreSkipped(ctx) </span><span class="cov8" title="1">{
                currTime := time.Now().In(boil.GetLocation())

                o.UpdatedAt = currTime
        }</span>

        <span class="cov8" title="1">var err error
        if err = o.doBeforeUpdateHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">key := makeCacheKey(columns, nil)
        userUpdateCacheMut.RLock()
        cache, cached := userUpdateCache[key]
        userUpdateCacheMut.RUnlock()

        if !cached </span><span class="cov8" title="1">{
                wl := columns.UpdateColumnSet(
                        userAllColumns,
                        userPrimaryKeyColumns,
                )

                if !columns.IsWhitelist() </span><span class="cov8" title="1">{
                        wl = strmangle.SetComplement(wl, []string{"created_at"})
                }</span>
                <span class="cov8" title="1">if len(wl) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("models: unable to update users, could not build whitelist")
                }</span>

                <span class="cov8" title="1">cache.query = fmt.Sprintf("UPDATE `users` SET %s WHERE %s",
                        strmangle.SetParamNames("`", "`", 0, wl),
                        strmangle.WhereClause("`", "`", 0, userPrimaryKeyColumns),
                )
                cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, values)
        }</span>
        <span class="cov8" title="1">var result sql.Result
        result, err = exec.ExecContext(ctx, cache.query, values...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update users row")
        }</span>

        <span class="cov8" title="1">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by update for users")
        }</span>

        <span class="cov8" title="1">if !cached </span><span class="cov8" title="1">{
                userUpdateCacheMut.Lock()
                userUpdateCache[key] = cache
                userUpdateCacheMut.Unlock()
        }</span>

        <span class="cov8" title="1">return rowsAff, o.doAfterUpdateHooks(ctx, exec)</span>
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        queries.SetUpdate(q.Query, cols)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all for users")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected for users")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) <span class="cov0" title="0">{
        ln := int64(len(o))
        if ln == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(cols) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: update all requires at least one column argument")
        }</span>

        <span class="cov0" title="0">colNames := make([]string, len(cols))
        args := make([]interface{}, len(cols))

        i := 0
        for name, value := range cols </span><span class="cov0" title="0">{
                colNames[i] = name
                args[i] = value
                i++
        }</span>

        // Append all of the primary key values for each column
        <span class="cov0" title="0">for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := fmt.Sprintf("UPDATE `users` SET %s WHERE %s",
                strmangle.SetParamNames("`", "`", 0, colNames),
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o)))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to update all in user slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all user")
        }</span>
        <span class="cov0" title="0">return rowsAff, nil</span>
}

var mySQLUserUniqueColumns = []string{
        "id",
        "email",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return errors.New("models: no users provided for upsert")
        }</span>
        <span class="cov0" title="0">if !boil.TimestampsAreSkipped(ctx) </span><span class="cov0" title="0">{
                currTime := time.Now().In(boil.GetLocation())

                if o.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                        o.CreatedAt = currTime
                }</span>
                <span class="cov0" title="0">o.UpdatedAt = currTime</span>
        }

        <span class="cov0" title="0">if err := o.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)
        nzUniques := queries.NonZeroDefaultSet(mySQLUserUniqueColumns, o)

        if len(nzUniques) == 0 </span><span class="cov0" title="0">{
                return errors.New("cannot upsert with a table that cannot conflict on a unique column")
        }</span>

        // Build cache key in-line uglily - mysql vs psql problems
        <span class="cov0" title="0">buf := strmangle.GetBuffer()
        buf.WriteString(strconv.Itoa(updateColumns.Kind))
        for _, c := range updateColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        buf.WriteString(strconv.Itoa(insertColumns.Kind))
        for _, c := range insertColumns.Cols </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzDefaults </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        for _, c := range nzUniques </span><span class="cov0" title="0">{
                buf.WriteString(c)
        }</span>
        <span class="cov0" title="0">key := buf.String()
        strmangle.PutBuffer(buf)

        userUpsertCacheMut.RLock()
        cache, cached := userUpsertCache[key]
        userUpsertCacheMut.RUnlock()

        var err error

        if !cached </span><span class="cov0" title="0">{
                insert, _ := insertColumns.InsertColumnSet(
                        userAllColumns,
                        userColumnsWithDefault,
                        userColumnsWithoutDefault,
                        nzDefaults,
                )

                update := updateColumns.UpdateColumnSet(
                        userAllColumns,
                        userPrimaryKeyColumns,
                )

                if !updateColumns.IsNone() &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                        return errors.New("models: unable to upsert users, could not build update column list")
                }</span>

                <span class="cov0" title="0">ret := strmangle.SetComplement(userAllColumns, strmangle.SetIntersect(insert, update))

                cache.query = buildUpsertQueryMySQL(dialect, "`users`", update, insert)
                cache.retQuery = fmt.Sprintf(
                        "SELECT %s FROM `users` WHERE %s",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
                        strmangle.WhereClause("`", "`", 0, nzUniques),
                )

                cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(ret) != 0 </span><span class="cov0" title="0">{
                        cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(o))
        vals := queries.ValuesFromMapping(value, cache.valueMapping)
        var returns []interface{}
        if len(cache.retMapping) != 0 </span><span class="cov0" title="0">{
                returns = queries.PtrsFromMapping(value, cache.retMapping)
        }</span>

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.query)
                fmt.Fprintln(writer, vals)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, cache.query, vals...)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to upsert for users")
        }</span>

        <span class="cov0" title="0">var lastID int64
        var uniqueMap []uint64
        var nzUniqueCols []interface{}

        if len(cache.retMapping) == 0 </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">lastID, err = result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return ErrSyncFail
        }</span>

        <span class="cov0" title="0">o.ID = int(lastID)
        if lastID != 0 &amp;&amp; len(cache.retMapping) == 1 &amp;&amp; cache.retMapping[0] == userMapping["id"] </span><span class="cov0" title="0">{
                goto CacheNoHooks</span>
        }

        <span class="cov0" title="0">uniqueMap, err = queries.BindMapping(userType, userMapping, nzUniques)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to retrieve unique values for users")
        }</span>
        <span class="cov0" title="0">nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, cache.retQuery)
                fmt.Fprintln(writer, nzUniqueCols...)
        }</span>
        <span class="cov0" title="0">err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to populate default values for users")
        }</span>

CacheNoHooks:
        <span class="cov0" title="0">if !cached </span><span class="cov0" title="0">{
                userUpsertCacheMut.Lock()
                userUpsertCache[key] = cache
                userUpsertCacheMut.Unlock()
        }</span>

        <span class="cov0" title="0">return o.doAfterUpsertHooks(ctx, exec)</span>
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no User provided for delete")
        }</span>

        <span class="cov0" title="0">if err := o.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
        sql := "DELETE FROM `users` WHERE `id`=?"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args...)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete from users")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by delete for users")
        }</span>

        <span class="cov0" title="0">if err := o.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if q.Query == nil </span><span class="cov0" title="0">{
                return 0, errors.New("models: no userQuery provided for delete all")
        }</span>

        <span class="cov0" title="0">queries.SetDelete(q.Query)

        result, err := q.Query.ExecContext(ctx, exec)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from users")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for users")
        }</span>

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">if len(userBeforeDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">var args []interface{}
        for _, obj := range o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := "DELETE FROM `users` WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(o))

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, args)
        }</span>
        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to delete all from user slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for users")
        }</span>

        <span class="cov0" title="0">if len(userAfterDeleteHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterDeleteHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error <span class="cov8" title="1">{
        ret, err := FindUser(ctx, exec, o.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*o = *ret
        return nil</span>
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error <span class="cov0" title="0">{
        if o == nil || len(*o) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">slice := UserSlice{}
        var args []interface{}
        for _, obj := range *o </span><span class="cov0" title="0">{
                pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
                args = append(args, pkeyArgs...)
        }</span>

        <span class="cov0" title="0">sql := "SELECT `users`.* FROM `users` WHERE " +
                strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, userPrimaryKeyColumns, len(*o))

        q := queries.Raw(sql, args...)

        err := q.Bind(ctx, exec, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "models: unable to reload all in UserSlice")
        }</span>

        <span class="cov0" title="0">*o = slice

        return nil</span>
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) <span class="cov0" title="0">{
        var exists bool
        sql := "select exists(select 1 from `users` where `id`=? limit 1)"

        if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, iD)
        }</span>
        <span class="cov0" title="0">row := exec.QueryRowContext(ctx, sql, iD)

        err := row.Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "models: unable to check if users exists")
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// Exists checks if the User row exists.
func (o *User) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) <span class="cov0" title="0">{
        return UserExists(ctx, exec, o.ID)
}</span>

// /////////////////////////////// BEGIN EXTENSIONS /////////////////////////////////
// Expose table columns
var (
        UserAllColumns            = userAllColumns
        UserColumnsWithoutDefault = userColumnsWithoutDefault
        UserColumnsWithDefault    = userColumnsWithDefault
        UserPrimaryKeyColumns     = userPrimaryKeyColumns
        UserGeneratedColumns      = userGeneratedColumns
)

// GetID get ID from model object
func (o *User) GetID() int <span class="cov0" title="0">{
        return o.ID
}</span>

// GetIDs extract IDs from model objects
func (s UserSlice) GetIDs() []int <span class="cov0" title="0">{
        result := make([]int, len(s))
        for i := range s </span><span class="cov0" title="0">{
                result[i] = s[i].ID
        }</span>
        <span class="cov0" title="0">return result</span>
}

// GetIntfIDs extract IDs from model objects as interface slice
func (s UserSlice) GetIntfIDs() []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, len(s))
        for i := range s </span><span class="cov0" title="0">{
                result[i] = s[i].ID
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToIDMap convert a slice of model objects to a map with ID as key
func (s UserSlice) ToIDMap() map[int]*User <span class="cov0" title="0">{
        result := make(map[int]*User, len(s))
        for _, o := range s </span><span class="cov0" title="0">{
                result[o.ID] = o
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToUniqueItems construct a slice of unique items from the given slice
func (s UserSlice) ToUniqueItems() UserSlice <span class="cov0" title="0">{
        result := make(UserSlice, 0, len(s))
        mapChk := make(map[int]struct{}, len(s))
        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                o := s[i]
                if _, ok := mapChk[o.ID]; !ok </span><span class="cov0" title="0">{
                        mapChk[o.ID] = struct{}{}
                        result = append(result, o)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// FindItemByID find item by ID in the slice
func (s UserSlice) FindItemByID(id int) *User <span class="cov0" title="0">{
        for _, o := range s </span><span class="cov0" title="0">{
                if o.ID == id </span><span class="cov0" title="0">{
                        return o
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// FindMissingItemIDs find all item IDs that are not in the list
// NOTE: the input ID slice should contain unique values
func (s UserSlice) FindMissingItemIDs(expectedIDs []int) []int <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return expectedIDs
        }</span>
        <span class="cov0" title="0">result := []int{}
        mapChk := s.ToIDMap()
        for _, id := range expectedIDs </span><span class="cov0" title="0">{
                if _, ok := mapChk[id]; !ok </span><span class="cov0" title="0">{
                        result = append(result, id)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// InsertAll inserts all rows with the specified column values, using an executor.
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o UserSlice) InsertAll(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Calculate the widest columns from all rows need to insert
        <span class="cov0" title="0">wlCols := make(map[string]struct{}, 10)
        for _, row := range o </span><span class="cov0" title="0">{
                wl, _ := columns.InsertColumnSet(
                        userAllColumns,
                        userColumnsWithDefault,
                        userColumnsWithoutDefault,
                        queries.NonZeroDefaultSet(userColumnsWithDefault, row),
                )
                for _, col := range wl </span><span class="cov0" title="0">{
                        wlCols[col] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">wl := make([]string, 0, len(wlCols))
        for _, col := range userAllColumns </span><span class="cov0" title="0">{
                if _, ok := wlCols[col]; ok </span><span class="cov0" title="0">{
                        wl = append(wl, col)
                }</span>
        }

        <span class="cov0" title="0">var sql string
        vals := []interface{}{}
        for i, row := range o </span><span class="cov0" title="0">{
                if !boil.TimestampsAreSkipped(ctx) </span><span class="cov0" title="0">{
                        currTime := time.Now().In(boil.GetLocation())
                        if row.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                                row.CreatedAt = currTime
                        }</span>
                        <span class="cov0" title="0">if row.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                                row.UpdatedAt = currTime
                        }</span>
                }

                <span class="cov0" title="0">if err := row.doBeforeInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">if i == 0 </span><span class="cov0" title="0">{
                        sql = "INSERT INTO `users` " + "(`" + strings.Join(wl, "`,`") + "`)" + " VALUES "
                }</span>
                <span class="cov0" title="0">sql += strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), len(vals)+1, len(wl))
                if i != len(o)-1 </span><span class="cov0" title="0">{
                        sql += ","
                }</span>
                <span class="cov0" title="0">valMapping, err := queries.BindMapping(userType, userMapping, wl)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(row))
                vals = append(vals, queries.ValuesFromMapping(value, valMapping)...)</span>
        }

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, sql)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, sql, vals...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to insert all from user slice")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by insertall for users")
        }</span>

        <span class="cov0" title="0">if len(userAfterInsertHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterInsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// InsertIgnoreAll inserts all rows with ignoring the existing ones having the same primary key values.
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o UserSlice) InsertIgnoreAll(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) <span class="cov0" title="0">{
        return o.UpsertAll(ctx, exec, boil.None(), columns)
}</span>

// UpsertAll inserts or updates all rows
// Currently it doesn't support "NoContext" and "NoRowsAffected"
// IMPORTANT: this will calculate the widest columns from all items in the slice, be careful if you want to use default column values
func (o UserSlice) UpsertAll(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) (int64, error) <span class="cov0" title="0">{
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Calculate the widest columns from all rows need to upsert
        <span class="cov0" title="0">insertCols := make(map[string]struct{}, 10)
        for _, row := range o </span><span class="cov0" title="0">{
                nzUniques := queries.NonZeroDefaultSet(mySQLUserUniqueColumns, row)
                if len(nzUniques) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("cannot upsert with a table that cannot conflict on a unique column")
                }</span>
                <span class="cov0" title="0">insert, _ := insertColumns.InsertColumnSet(
                        userAllColumns,
                        userColumnsWithDefault,
                        userColumnsWithoutDefault,
                        queries.NonZeroDefaultSet(userColumnsWithDefault, row),
                )
                for _, col := range insert </span><span class="cov0" title="0">{
                        insertCols[col] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">insert := make([]string, 0, len(insertCols))
        for _, col := range userAllColumns </span><span class="cov0" title="0">{
                if _, ok := insertCols[col]; ok </span><span class="cov0" title="0">{
                        insert = append(insert, col)
                }</span>
        }

        <span class="cov0" title="0">update := updateColumns.UpdateColumnSet(
                userAllColumns,
                userPrimaryKeyColumns,
        )
        if !updateColumns.IsNone() &amp;&amp; len(update) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("models: unable to upsert users, could not build update column list")
        }</span>

        <span class="cov0" title="0">buf := strmangle.GetBuffer()
        defer strmangle.PutBuffer(buf)

        if len(update) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(
                        buf,
                        "INSERT IGNORE INTO `users`(%s) VALUES %s",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, insert), ","),
                        strmangle.Placeholders(false, len(insert)*len(o), 1, len(insert)),
                )
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(
                        buf,
                        "INSERT INTO `users`(%s) VALUES %s ON DUPLICATE KEY UPDATE ",
                        strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, insert), ","),
                        strmangle.Placeholders(false, len(insert)*len(o), 1, len(insert)),
                )

                for i, v := range update </span><span class="cov0" title="0">{
                        if i != 0 </span><span class="cov0" title="0">{
                                buf.WriteByte(',')
                        }</span>
                        <span class="cov0" title="0">quoted := strmangle.IdentQuote(dialect.LQ, dialect.RQ, v)
                        buf.WriteString(quoted)
                        buf.WriteString(" = VALUES(")
                        buf.WriteString(quoted)
                        buf.WriteByte(')')</span>
                }
        }

        <span class="cov0" title="0">query := buf.String()
        valueMapping, err := queries.BindMapping(userType, userMapping, insert)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var vals []interface{}
        for _, row := range o </span><span class="cov0" title="0">{
                if !boil.TimestampsAreSkipped(ctx) </span><span class="cov0" title="0">{
                        currTime := time.Now().In(boil.GetLocation())
                        if row.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                                row.CreatedAt = currTime
                        }</span>

                        <span class="cov0" title="0">row.UpdatedAt = currTime</span>
                }

                <span class="cov0" title="0">if err := row.doBeforeUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">value := reflect.Indirect(reflect.ValueOf(row))
                vals = append(vals, queries.ValuesFromMapping(value, valueMapping)...)</span>
        }

        <span class="cov0" title="0">if boil.IsDebug(ctx) </span><span class="cov0" title="0">{
                writer := boil.DebugWriterFrom(ctx)
                fmt.Fprintln(writer, query)
                fmt.Fprintln(writer, vals)
        }</span>

        <span class="cov0" title="0">result, err := exec.ExecContext(ctx, query, vals...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: unable to upsert for users")
        }</span>

        <span class="cov0" title="0">rowsAff, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.Wrap(err, "models: failed to get rows affected by upsert for users")
        }</span>

        <span class="cov0" title="0">if len(userAfterUpsertHooks) != 0 </span><span class="cov0" title="0">{
                for _, obj := range o </span><span class="cov0" title="0">{
                        if err := obj.doAfterUpsertHooks(ctx, exec); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return rowsAff, nil</span>
}

// DeleteAllByPage delete all User records from the slice.
// This function deletes data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s UserSlice) DeleteAllByPage(ctx context.Context, exec boil.ContextExecutor, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := DefaultPageSize
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt;= MaxPageSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.DeleteAll(ctx, exec)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].DeleteAll(ctx, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// UpdateAllByPage update all User records from the slice.
// This function updates data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s UserSlice) UpdateAllByPage(ctx context.Context, exec boil.ContextExecutor, cols M, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        // NOTE (eric): len(cols) should not be too big
        <span class="cov0" title="0">chunkSize := DefaultPageSize
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt;= MaxPageSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.UpdateAll(ctx, exec, cols)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].UpdateAll(ctx, exec, cols)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// InsertAllByPage insert all User records from the slice.
// This function inserts data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s UserSlice) InsertAllByPage(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;UserColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.InsertAll(ctx, exec, columns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].InsertAll(ctx, exec, columns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// InsertIgnoreAllByPage insert all User records from the slice.
// This function inserts data by pages to avoid exceeding Postgres limitation (max parameters: 65535)
func (s UserSlice) InsertIgnoreAllByPage(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // max number of parameters = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;UserColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.InsertIgnoreAll(ctx, exec, columns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].InsertIgnoreAll(ctx, exec, columns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

// UpsertAllByPage upsert all User records from the slice.
// This function upserts data by pages to avoid exceeding Mysql limitation (max placeholders: 65535)
// Mysql Error 1390: Prepared statement contains too many placeholders.
func (s UserSlice) UpsertAllByPage(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns, limits ...int) (int64, error) <span class="cov0" title="0">{
        length := len(s)
        if length == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // MySQL max placeholders = 65535
        <span class="cov0" title="0">chunkSize := MaxPageSize / reflect.ValueOf(&amp;UserColumns).Elem().NumField()
        if len(limits) &gt; 0 &amp;&amp; limits[0] &gt; 0 &amp;&amp; limits[0] &lt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = limits[0]
        }</span>
        <span class="cov0" title="0">if length &lt;= chunkSize </span><span class="cov0" title="0">{
                return s.UpsertAll(ctx, exec, updateColumns, insertColumns)
        }</span>

        <span class="cov0" title="0">rowsAffected := int64(0)
        start := 0
        for </span><span class="cov0" title="0">{
                end := start + chunkSize
                if end &gt; length </span><span class="cov0" title="0">{
                        end = length
                }</span>
                <span class="cov0" title="0">rows, err := s[start:end].UpsertAll(ctx, exec, updateColumns, insertColumns)
                if err != nil </span><span class="cov0" title="0">{
                        return rowsAffected, err
                }</span>

                <span class="cov0" title="0">rowsAffected += rows
                start = end
                if start &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return rowsAffected, nil</span>
}

///////////////////////////////// END EXTENSIONS /////////////////////////////////
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package apis provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package apis

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "mime/multipart"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
        strictecho "github.com/oapi-codegen/runtime/strictmiddleware/echo"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        CookieAuthScopes = "cookieAuth.Scopes"
)

// SignUpValidationError defines model for SignUpValidationError.
type SignUpValidationError struct {
        BackIdentification  *[]string `json:"backIdentification,omitempty"`
        Birthday            *[]string `json:"birthday,omitempty"`
        Email               *[]string `json:"email,omitempty"`
        FirstName           *[]string `json:"firstName,omitempty"`
        FrontIdentification *[]string `json:"frontIdentification,omitempty"`
        LastName            *[]string `json:"lastName,omitempty"`
        Password            *[]string `json:"password,omitempty"`
}

// StoreTodoValidationError defines model for StoreTodoValidationError.
type StoreTodoValidationError struct {
        Content *[]string `json:"content,omitempty"`
        Title   *[]string `json:"title,omitempty"`
}

// Todo defines model for Todo.
type Todo struct {
        Content string `json:"content"`
        Id      int    `json:"id"`
        Title   string `json:"title"`
}

// CsrfResponse defines model for CsrfResponse.
type CsrfResponse struct {
        CsrfToken string `json:"csrf_token"`
}

// DeleteTodoResponse defines model for DeleteTodoResponse.
type DeleteTodoResponse struct {
        Code   int  `json:"code"`
        Result bool `json:"result"`
}

// FetchTodosResponse defines model for FetchTodosResponse.
type FetchTodosResponse struct {
        Todos []Todo `json:"todos"`
}

// InternalServerErrorResponse defines model for InternalServerErrorResponse.
type InternalServerErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// NotFoundErrorResponse defines model for NotFoundErrorResponse.
type NotFoundErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// ShowTodoResponse defines model for ShowTodoResponse.
type ShowTodoResponse struct {
        Todo Todo `json:"todo"`
}

// SignInBadRequestResponse defines model for SignInBadRequestResponse.
type SignInBadRequestResponse struct {
        Errors []string `json:"errors"`
}

// SignInOkResponse defines model for SignInOkResponse.
type SignInOkResponse = map[string]interface{}

// SignUpResponse defines model for SignUpResponse.
type SignUpResponse struct {
        Code   int                   `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

// StoreTodoResponse defines model for StoreTodoResponse.
type StoreTodoResponse struct {
        Code   int                      `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

// UnauthorizedErrorResponse defines model for UnauthorizedErrorResponse.
type UnauthorizedErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// SignInInput defines model for SignInInput.
type SignInInput struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// StoreTodoInput defines model for StoreTodoInput.
type StoreTodoInput struct {
        Content string `json:"content"`
        Title   string `json:"title"`
}

// PostAuthSignInJSONBody defines parameters for PostAuthSignIn.
type PostAuthSignInJSONBody struct {
        Email    string `json:"email"`
        Password string `json:"password"`
}

// PostAuthSignUpMultipartBody defines parameters for PostAuthSignUp.
type PostAuthSignUpMultipartBody struct {
        BackIdentification  *openapi_types.File `json:"backIdentification,omitempty"`
        Birthday            *openapi_types.Date `json:"birthday,omitempty"`
        Email               string              `json:"email"`
        FirstName           string              `json:"firstName"`
        FrontIdentification *openapi_types.File `json:"frontIdentification,omitempty"`
        LastName            string              `json:"lastName"`
        Password            string              `json:"password"`
}

// PostAuthValidateSignUpMultipartBody defines parameters for PostAuthValidateSignUp.
type PostAuthValidateSignUpMultipartBody struct {
        BackIdentification  *openapi_types.File `json:"backIdentification,omitempty"`
        Birthday            *openapi_types.Date `json:"birthday,omitempty"`
        Email               string              `json:"email"`
        FirstName           string              `json:"firstName"`
        FrontIdentification *openapi_types.File `json:"frontIdentification,omitempty"`
        LastName            string              `json:"lastName"`
        Password            string              `json:"password"`
}

// PostTodosJSONBody defines parameters for PostTodos.
type PostTodosJSONBody struct {
        Content string `json:"content"`
        Title   string `json:"title"`
}

// PatchTodoJSONBody defines parameters for PatchTodo.
type PatchTodoJSONBody struct {
        Content string `json:"content"`
        Title   string `json:"title"`
}

// PostAuthSignInJSONRequestBody defines body for PostAuthSignIn for application/json ContentType.
type PostAuthSignInJSONRequestBody PostAuthSignInJSONBody

// PostAuthSignUpMultipartRequestBody defines body for PostAuthSignUp for multipart/form-data ContentType.
type PostAuthSignUpMultipartRequestBody PostAuthSignUpMultipartBody

// PostAuthValidateSignUpMultipartRequestBody defines body for PostAuthValidateSignUp for multipart/form-data ContentType.
type PostAuthValidateSignUpMultipartRequestBody PostAuthValidateSignUpMultipartBody

// PostTodosJSONRequestBody defines body for PostTodos for application/json ContentType.
type PostTodosJSONRequestBody PostTodosJSONBody

// PatchTodoJSONRequestBody defines body for PatchTodo for application/json ContentType.
type PatchTodoJSONRequestBody PatchTodoJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Get Csrf
        // (GET /auth/csrf)
        GetAuthCsrf(ctx echo.Context) error
        // Sign In
        // (POST /auth/signIn)
        PostAuthSignIn(ctx echo.Context) error
        // SignUp
        // (POST /auth/signUp)
        PostAuthSignUp(ctx echo.Context) error
        // Validate SignUp
        // (POST /auth/validateSignUp)
        PostAuthValidateSignUp(ctx echo.Context) error
        // Fetch Todos
        // (GET /todos)
        GetTodos(ctx echo.Context) error
        // Create Todo
        // (POST /todos)
        PostTodos(ctx echo.Context) error
        // Delete Todo
        // (DELETE /todos/{id})
        DeleteTodo(ctx echo.Context, id string) error
        // Show Todo
        // (GET /todos/{id})
        GetTodo(ctx echo.Context, id string) error
        // Update Todo
        // (PATCH /todos/{id})
        PatchTodo(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// GetAuthCsrf converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthCsrf(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetAuthCsrf(ctx)
        return err
}</span>

// PostAuthSignIn converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSignIn(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostAuthSignIn(ctx)
        return err
}</span>

// PostAuthSignUp converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthSignUp(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostAuthSignUp(ctx)
        return err
}</span>

// PostAuthValidateSignUp converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthValidateSignUp(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostAuthValidateSignUp(ctx)
        return err
}</span>

// GetTodos converts echo context to params.
func (w *ServerInterfaceWrapper) GetTodos(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetTodos(ctx)
        return err
}</span>

// PostTodos converts echo context to params.
func (w *ServerInterfaceWrapper) PostTodos(ctx echo.Context) error <span class="cov8" title="1">{
        var err error

        ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PostTodos(ctx)
        return err
}</span>

// DeleteTodo converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTodo(ctx echo.Context) error <span class="cov8" title="1">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov8" title="1">ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.DeleteTodo(ctx, id)
        return err</span>
}

// GetTodo converts echo context to params.
func (w *ServerInterfaceWrapper) GetTodo(ctx echo.Context) error <span class="cov8" title="1">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov8" title="1">ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetTodo(ctx, id)
        return err</span>
}

// PatchTodo converts echo context to params.
func (w *ServerInterfaceWrapper) PatchTodo(ctx echo.Context) error <span class="cov8" title="1">{
        var err error
        // ------------- Path parameter "id" -------------
        var id string

        err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
        }</span>

        <span class="cov8" title="1">ctx.Set(CookieAuthScopes, []string{})

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.PatchTodo(ctx, id)
        return err</span>
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) <span class="cov8" title="1">{
        RegisterHandlersWithBaseURL(router, si, "")
}</span>

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) <span class="cov8" title="1">{

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/auth/csrf", wrapper.GetAuthCsrf)
        router.POST(baseURL+"/auth/signIn", wrapper.PostAuthSignIn)
        router.POST(baseURL+"/auth/signUp", wrapper.PostAuthSignUp)
        router.POST(baseURL+"/auth/validateSignUp", wrapper.PostAuthValidateSignUp)
        router.GET(baseURL+"/todos", wrapper.GetTodos)
        router.POST(baseURL+"/todos", wrapper.PostTodos)
        router.DELETE(baseURL+"/todos/:id", wrapper.DeleteTodo)
        router.GET(baseURL+"/todos/:id", wrapper.GetTodo)
        router.PATCH(baseURL+"/todos/:id", wrapper.PatchTodo)

}</span>

type CsrfResponseJSONResponse struct {
        CsrfToken string `json:"csrf_token"`
}

type DeleteTodoResponseJSONResponse struct {
        Code   int  `json:"code"`
        Result bool `json:"result"`
}

type FetchTodosResponseJSONResponse struct {
        Todos []Todo `json:"todos"`
}

type InternalServerErrorResponseJSONResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

type NotFoundErrorResponseJSONResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

type ShowTodoResponseJSONResponse struct {
        Todo Todo `json:"todo"`
}

type SignInBadRequestResponseJSONResponse struct {
        Errors []string `json:"errors"`
}

type SignInOkResponseResponseHeaders struct {
        SetCookie string
}
type SignInOkResponseJSONResponse struct {
        Body map[string]interface{}

        Headers SignInOkResponseResponseHeaders
}

type SignUpResponseJSONResponse struct {
        Code   int                   `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

type StoreTodoResponseJSONResponse struct {
        Code   int                      `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

type UnauthorizedErrorResponseJSONResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

type GetAuthCsrfRequestObject struct {
}

type GetAuthCsrfResponseObject interface {
        VisitGetAuthCsrfResponse(w http.ResponseWriter) error
}

type GetAuthCsrf200JSONResponse struct{ CsrfResponseJSONResponse }

func (response GetAuthCsrf200JSONResponse) VisitGetAuthCsrfResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetAuthCsrf500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response GetAuthCsrf500JSONResponse) VisitGetAuthCsrfResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignInRequestObject struct {
        Body *PostAuthSignInJSONRequestBody
}

type PostAuthSignInResponseObject interface {
        VisitPostAuthSignInResponse(w http.ResponseWriter) error
}

type PostAuthSignIn200JSONResponse struct{ SignInOkResponseJSONResponse }

func (response PostAuthSignIn200JSONResponse) VisitPostAuthSignInResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PostAuthSignIn400JSONResponse struct {
        SignInBadRequestResponseJSONResponse
}

func (response PostAuthSignIn400JSONResponse) VisitPostAuthSignInResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignIn500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostAuthSignIn500JSONResponse) VisitPostAuthSignInResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignUpRequestObject struct {
        Body *multipart.Reader
}

type PostAuthSignUpResponseObject interface {
        VisitPostAuthSignUpResponse(w http.ResponseWriter) error
}

type PostAuthSignUp200JSONResponse struct{ SignUpResponseJSONResponse }

func (response PostAuthSignUp200JSONResponse) VisitPostAuthSignUpResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignUp400JSONResponse struct {
        Code   int                   `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

func (response PostAuthSignUp400JSONResponse) VisitPostAuthSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthSignUp500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostAuthSignUp500JSONResponse) VisitPostAuthSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthValidateSignUpRequestObject struct {
        Body *multipart.Reader
}

type PostAuthValidateSignUpResponseObject interface {
        VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error
}

type PostAuthValidateSignUp200JSONResponse struct{ SignUpResponseJSONResponse }

func (response PostAuthValidateSignUp200JSONResponse) VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthValidateSignUp400JSONResponse struct {
        Code   int                   `json:"code"`
        Errors SignUpValidationError `json:"errors"`
}

func (response PostAuthValidateSignUp400JSONResponse) VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostAuthValidateSignUp500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostAuthValidateSignUp500JSONResponse) VisitPostAuthValidateSignUpResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodosRequestObject struct {
}

type GetTodosResponseObject interface {
        VisitGetTodosResponse(w http.ResponseWriter) error
}

type GetTodos200JSONResponse struct{ FetchTodosResponseJSONResponse }

func (response GetTodos200JSONResponse) VisitGetTodosResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodos401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response GetTodos401JSONResponse) VisitGetTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodos500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response GetTodos500JSONResponse) VisitGetTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodosRequestObject struct {
        Body *PostTodosJSONRequestBody
}

type PostTodosResponseObject interface {
        VisitPostTodosResponse(w http.ResponseWriter) error
}

type PostTodos200JSONResponse struct{ StoreTodoResponseJSONResponse }

func (response PostTodos200JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodos400JSONResponse struct {
        Code   int                      `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

func (response PostTodos400JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodos401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response PostTodos401JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostTodos500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PostTodos500JSONResponse) VisitPostTodosResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodoRequestObject struct {
        Id string `json:"id"`
}

type DeleteTodoResponseObject interface {
        VisitDeleteTodoResponse(w http.ResponseWriter) error
}

type DeleteTodo200JSONResponse struct{ DeleteTodoResponseJSONResponse }

func (response DeleteTodo200JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodo401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response DeleteTodo401JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodo404JSONResponse struct {
        NotFoundErrorResponseJSONResponse
}

func (response DeleteTodo404JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteTodo500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response DeleteTodo500JSONResponse) VisitDeleteTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodoRequestObject struct {
        Id string `json:"id"`
}

type GetTodoResponseObject interface {
        VisitGetTodoResponse(w http.ResponseWriter) error
}

type GetTodo200JSONResponse struct{ ShowTodoResponseJSONResponse }

func (response GetTodo200JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodo401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response GetTodo401JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodo404JSONResponse struct {
        NotFoundErrorResponseJSONResponse
}

func (response GetTodo404JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetTodo500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response GetTodo500JSONResponse) VisitGetTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodoRequestObject struct {
        Id   string `json:"id"`
        Body *PatchTodoJSONRequestBody
}

type PatchTodoResponseObject interface {
        VisitPatchTodoResponse(w http.ResponseWriter) error
}

type PatchTodo200JSONResponse struct{ StoreTodoResponseJSONResponse }

func (response PatchTodo200JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo400JSONResponse struct {
        Code   int                      `json:"code"`
        Errors StoreTodoValidationError `json:"errors"`
}

func (response PatchTodo400JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo401JSONResponse struct {
        UnauthorizedErrorResponseJSONResponse
}

func (response PatchTodo401JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo404JSONResponse struct {
        NotFoundErrorResponseJSONResponse
}

func (response PatchTodo404JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchTodo500JSONResponse struct {
        InternalServerErrorResponseJSONResponse
}

func (response PatchTodo500JSONResponse) VisitPatchTodoResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Get Csrf
        // (GET /auth/csrf)
        GetAuthCsrf(ctx context.Context, request GetAuthCsrfRequestObject) (GetAuthCsrfResponseObject, error)
        // Sign In
        // (POST /auth/signIn)
        PostAuthSignIn(ctx context.Context, request PostAuthSignInRequestObject) (PostAuthSignInResponseObject, error)
        // SignUp
        // (POST /auth/signUp)
        PostAuthSignUp(ctx context.Context, request PostAuthSignUpRequestObject) (PostAuthSignUpResponseObject, error)
        // Validate SignUp
        // (POST /auth/validateSignUp)
        PostAuthValidateSignUp(ctx context.Context, request PostAuthValidateSignUpRequestObject) (PostAuthValidateSignUpResponseObject, error)
        // Fetch Todos
        // (GET /todos)
        GetTodos(ctx context.Context, request GetTodosRequestObject) (GetTodosResponseObject, error)
        // Create Todo
        // (POST /todos)
        PostTodos(ctx context.Context, request PostTodosRequestObject) (PostTodosResponseObject, error)
        // Delete Todo
        // (DELETE /todos/{id})
        DeleteTodo(ctx context.Context, request DeleteTodoRequestObject) (DeleteTodoResponseObject, error)
        // Show Todo
        // (GET /todos/{id})
        GetTodo(ctx context.Context, request GetTodoRequestObject) (GetTodoResponseObject, error)
        // Update Todo
        // (PATCH /todos/{id})
        PatchTodo(ctx context.Context, request PatchTodoRequestObject) (PatchTodoResponseObject, error)
}

type StrictHandlerFunc = strictecho.StrictEchoHandlerFunc
type StrictMiddlewareFunc = strictecho.StrictEchoMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov8" title="1">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
}

// GetAuthCsrf operation middleware
func (sh *strictHandler) GetAuthCsrf(ctx echo.Context) error <span class="cov8" title="1">{
        var request GetAuthCsrfRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.GetAuthCsrf(ctx.Request().Context(), request.(GetAuthCsrfRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "GetAuthCsrf")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(GetAuthCsrfResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitGetAuthCsrfResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostAuthSignIn operation middleware
func (sh *strictHandler) PostAuthSignIn(ctx echo.Context) error <span class="cov8" title="1">{
        var request PostAuthSignInRequestObject

        var body PostAuthSignInJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.PostAuthSignIn(ctx.Request().Context(), request.(PostAuthSignInRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "PostAuthSignIn")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(PostAuthSignInResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitPostAuthSignInResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostAuthSignUp operation middleware
func (sh *strictHandler) PostAuthSignUp(ctx echo.Context) error <span class="cov8" title="1">{
        var request PostAuthSignUpRequestObject

        if reader, err := ctx.Request().MultipartReader(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                request.Body = reader
        }</span>

        <span class="cov8" title="1">handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.PostAuthSignUp(ctx.Request().Context(), request.(PostAuthSignUpRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "PostAuthSignUp")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(PostAuthSignUpResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitPostAuthSignUpResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostAuthValidateSignUp operation middleware
func (sh *strictHandler) PostAuthValidateSignUp(ctx echo.Context) error <span class="cov8" title="1">{
        var request PostAuthValidateSignUpRequestObject

        if reader, err := ctx.Request().MultipartReader(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                request.Body = reader
        }</span>

        <span class="cov8" title="1">handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.PostAuthValidateSignUp(ctx.Request().Context(), request.(PostAuthValidateSignUpRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "PostAuthValidateSignUp")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(PostAuthValidateSignUpResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitPostAuthValidateSignUpResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTodos operation middleware
func (sh *strictHandler) GetTodos(ctx echo.Context) error <span class="cov8" title="1">{
        var request GetTodosRequestObject

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.GetTodos(ctx.Request().Context(), request.(GetTodosRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "GetTodos")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(GetTodosResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitGetTodosResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PostTodos operation middleware
func (sh *strictHandler) PostTodos(ctx echo.Context) error <span class="cov8" title="1">{
        var request PostTodosRequestObject

        var body PostTodosJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.PostTodos(ctx.Request().Context(), request.(PostTodosRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "PostTodos")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(PostTodosResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitPostTodosResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteTodo operation middleware
func (sh *strictHandler) DeleteTodo(ctx echo.Context, id string) error <span class="cov8" title="1">{
        var request DeleteTodoRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.DeleteTodo(ctx.Request().Context(), request.(DeleteTodoRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "DeleteTodo")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(DeleteTodoResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitDeleteTodoResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetTodo operation middleware
func (sh *strictHandler) GetTodo(ctx echo.Context, id string) error <span class="cov8" title="1">{
        var request GetTodoRequestObject

        request.Id = id

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.GetTodo(ctx.Request().Context(), request.(GetTodoRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "GetTodo")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(GetTodoResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitGetTodoResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// PatchTodo operation middleware
func (sh *strictHandler) PatchTodo(ctx echo.Context, id string) error <span class="cov8" title="1">{
        var request PatchTodoRequestObject

        request.Id = id

        var body PatchTodoJSONRequestBody
        if err := ctx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">request.Body = &amp;body

        handler := func(ctx echo.Context, request interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return sh.ssi.PatchTodo(ctx.Request().Context(), request.(PatchTodoRequestObject))
        }</span>
        <span class="cov8" title="1">for _, middleware := range sh.middlewares </span><span class="cov8" title="1">{
                handler = middleware(handler, "PatchTodo")
        }</span>

        <span class="cov8" title="1">response, err := handler(ctx, request)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if validResponse, ok := response.(PatchTodoResponseObject); ok </span><span class="cov8" title="1">{
                return validResponse.VisitPatchTodoResponse(ctx.Response())
        }</span> else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response type: %T", response)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "H4sIAAAAAAAC/+xYTY/bNhP+KwLf96hETpsCgW5J2gRGgU2wjnNZGAVtjS1mJZIlqV24C/33YihZola0",
        "TTvroovmJsuc0TzPfHBmHshKlFJw4EaT9IEo+LMCbd6JjIF9MWMbPuVTLiuDP1eCG+D2kUpZsBU1TPDk",
        "mxYc3+lVDiXFJ6mEBGVaLVBSVuCD2UogKdFGMb4hdUwk1fpeqMzzZx1bc5iCjKQ3rQ5HYhHvJMTyG6wM",
        "qVEkA71STKJZJG3Nj6IGQB3bF3Ppw1NWhWGSKpOshSpfZNTQQ5CWdHU7zYAbtm5ZwLcoSg1JyZJxqrYk",
        "HiNeMmXyjG4HxzNqwHd4P3FrprS5oiX4/1WCm7PMK+gBteHe6s1zVMbnO3Euo2ha7ZxohIIvIhPfG5eO",
        "2AirYaaA40CbY3GnKgQQmr5DY9VpKbhuTHqv1fq6ffE9yLRa/2HELfDjEJyzIdajhdHOZmTqVyjAWH88",
        "heEic1ln3MAGFGloqgrXV0shCqB8jAdVdOdDIKH6D2BWOYLQT4DCoB58YAZK+/B/BWuSkv8lfcFNGmmd",
        "4FdtyDV2UqXodhxoVmUIGoskslCia8dPU25AcVrMQN2B+k0poS7qsBK0ppuAHGodtjsfgnGHJWrARBbN",
        "AO2VMB9ExbPnjfNKmMjC8CCc5eL+ibIOgyssSj1RGVbEc3FvY3IIwd7P72h23TQeTwAFkKdh7o1r+6FE",
        "axWc0F709nvAfbo9C1TotzvlMcmBZtBAn4F58V6IWwZerV181l1LdNEM6X1yKMAaQ77SgmX2gzbi9yXR",
        "CV4atAz/Bpw7Wy4Ddc5pZXKh2F/wzIufi2RU/+q4tbabU8axE9i1hxaKYfMeLtV18eEig/b+BDF/3x+u",
        "wG3/w6XcueCEqtu22HucNwoQJ4uPOtqJ83AYXct/DoZ9pnlgfGlv2/BhhGX+7AscUlhGYu+k0hpv7+VP",
        "jX3jvIyJhlWlmNnOMOF21uLt8rYyuSUM07V5RWLCbQCRZqToOZPsd9g2ec742jIwzPe3n6eaxERXZYnT",
        "aUpIbyJWAhKTO1C6Ofzq5QQZEBI4lYyk5OeX+AqD0eTWxARlEpxu8NcGLLXIuPXONCMp+QgGIeBIQx4N",
        "Yj9NJvsKeXcuGUxrdUx+CRE61Ie7bJP0ZuGy8RFM1Fpq6EajYy0rCxRqwGrbFNjYEtqD97PQFnDTPJDY",
        "Wfhs9xvu7IQSdyFUn0PZqCuqY/I6XNDTK16ad/xwZNk6RPtchtE+l+fSvttbnU270+WdQvpQ7OJUW4L2",
        "MX3XVFeYjRgflpLduQhdE1Wo0u+Sr0OFP1yzzzU7oqJDPur2Hm213b+YmDWdZjwuyPb/s6qxZ4VjyXx1",
        "XHR/03wBXoe3582iHhDtsOSQ3K5/sNnyBvx7Begce5Pv4RZDvif31Cgf7lzPC/TREBYc637J5+VYx0Ue",
        "x3bpkzywrG4cXICBsaubfetBV/cr2bMSybPRfRK+X09eH9fgX9z9495yWPamobfC9Vuuw/XtLK+M9n3/",
        "OZ909PoLI1W0BGNXYDftTILDQD+R2DmoH4yMqiA+sB1b2GFilY/9PJfZ0WpL28voR7V9hpHmONhXq60q",
        "/EQTapUqSEpyY2SaJIVY0SIX2qRvJm8mBPW28o+jCLmKgGdSMG76KLX9VB0/Pr2sNOOgdVRiZDG+iaiU",
        "vZT/73pR/x0AAP//IjjV/OQfAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov8" title="1">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov8" title="1">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov8" title="1">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov8" title="1">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov8" title="1">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov8" title="1">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov8" title="1">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov8" title="1">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov8" title="1">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        models "app/models/generated"
        apis "app/openapi"
        "app/validator"
        "context"
        "database/sql"
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"
        "time"

        "github.com/golang-jwt/jwt"
        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "golang.org/x/crypto/bcrypt"

        "cloud.google.com/go/storage"
)

type AuthService interface {
        ValidateSignUp(ctx context.Context, request *apis.PostAuthValidateSignUpMultipartRequestBody) error
        SignUp(ctx context.Context, requestParams apis.PostAuthSignUpMultipartRequestBody) error
        SignIn(ctx context.Context, requestParams apis.PostAuthSignInJSONBody) (statusCode int, tokenString string, error error)
        // GetAuthUser(ctx echo.Context) (*models.User, error)
        // Getuser(ctx context.Context, id int) *models.User
}

type authService struct {
        db *sql.DB
}

func NewAuthService(db *sql.DB) AuthService <span class="cov8" title="1">{
        return &amp;authService{db}
}</span>

func (as *authService) ValidateSignUp(ctx context.Context, request *apis.PostAuthValidateSignUpMultipartRequestBody) error <span class="cov8" title="1">{
        return validator.ValidateSignUp(request)
}</span>

func (as *authService) SignUp(ctx context.Context, requestParams apis.PostAuthSignUpMultipartRequestBody) error <span class="cov8" title="1">{
        user := models.User{}
        user.FirstName = requestParams.FirstName
        user.LastName = requestParams.LastName
        user.Email = requestParams.Email
        if requestParams.Birthday != nil </span><span class="cov8" title="1">{
                user.Birthday = null.Time{Time: requestParams.Birthday.Time, Valid: true}
        }</span>
        <span class="cov8" title="1">user.FrontIdentification = ""
        user.BackIdentification = ""

        // NOTE: パスワードをハッシュ化の上、Create処理
        hashedPassword, err := as.encryptPassword(requestParams.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">user.Password = hashedPassword
        createErr := user.Insert(ctx, as.db, boil.Infer())
        if createErr != nil </span><span class="cov0" title="0">{
                return createErr
        }</span>

        <span class="cov8" title="1">client, err := storage.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer client.Close()

        if requestParams.FrontIdentification == nil &amp;&amp; requestParams.BackIdentification == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">user.Reload(ctx, as.db)
        userID := strconv.Itoa(user.ID)

        bucket := client.Bucket(os.Getenv("STORAGE_BUCKET_NAME"))

        if requestParams.FrontIdentification != nil </span><span class="cov8" title="1">{
                frontIdentificationPath := "users/"+userID+"/"+requestParams.FrontIdentification.Filename()
                reader, _ :=requestParams.FrontIdentification.Reader()
                uploadFrontIdentificationErr := as.uploadIdentification(bucket, frontIdentificationPath, reader)
                if uploadFrontIdentificationErr != nil </span><span class="cov0" title="0">{
                        return uploadFrontIdentificationErr
                }</span>
                <span class="cov8" title="1">user.FrontIdentification = frontIdentificationPath</span>
        }
        <span class="cov8" title="1">if requestParams.BackIdentification != nil </span><span class="cov8" title="1">{
                backIdentificationPath := "users/"+userID+"/"+requestParams.BackIdentification.Filename()
                backIdentificationReader, _ :=requestParams.BackIdentification.Reader()
                uploadBackIdentificationErr := as.uploadIdentification(bucket, backIdentificationPath, backIdentificationReader)
                if uploadBackIdentificationErr != nil </span><span class="cov0" title="0">{
                        return uploadBackIdentificationErr
                }</span>
                <span class="cov8" title="1">user.BackIdentification = backIdentificationPath</span>
        }
        <span class="cov8" title="1">_, updateIdenfiticationErr := user.Update(ctx, as.db, boil.Infer())
        return updateIdenfiticationErr</span>
}

func (as *authService) SignIn(ctx context.Context, requestParams apis.PostAuthSignInJSONBody) (statusCode int, tokenString string, error error) <span class="cov8" title="1">{
        // NOTE: emailからの取得
        user, err := models.Users(qm.Where("email = ?", requestParams.Email)).One(ctx, as.db)
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusBadRequest, "", fmt.Errorf("メールアドレスまたはパスワードに該当する%sが存在しません。", "ユーザ")
        }</span>

        // NOTE: パスワードの照合
        <span class="cov8" title="1">if err := as.compareHashPassword(user.Password, requestParams.Password); err != nil </span><span class="cov0" title="0">{
                return http.StatusBadRequest, "", fmt.Errorf("メールアドレスまたはパスワードに該当する%sが存在しません。", "ユーザ")
        }</span>
        <span class="cov8" title="1">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id": user.ID,
                "exp":     time.Now().Add(time.Hour * 24).Unix(),
        })
        tokenString, err = token.SignedString([]byte(os.Getenv("JWT_TOKEN_KEY")))
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, "", err
        }</span>
        <span class="cov8" title="1">return http.StatusOK, tokenString, nil</span>
}

// // func (as *authService) GetAuthUser(ctx echo.Context) (*models.User, error) {
// //         // NOTE: Cookieからtokenを取得
// //         tokenString, err := ctx.Cookie("token")
// //         if err != nil {
// //                 return &amp;models.User{}, err
// //         }
// //         // NOTE: tokenに該当するユーザを取得する
// //         token, err := jwt.Parse(tokenString.Value, func(token *jwt.Token) (interface{}, error) {
// //                 if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// //                         return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
// //                 }

// //                 return []byte("abcdefghijklmn"), nil
// //         })
// //         if err != nil {
// //                 return &amp;models.User{}, fmt.Errorf("failt jwt parse")
// //         }

// //         var userID int
// //         if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid {
// //                 userID = int(claims["user_id"].(float64))
// //         }
// //         if userID == 0 {
// //                 return &amp;models.User{}, fmt.Errorf("invalid token")
// //         }
// //         user, err := models.FindUser(context.Background(), as.db, userID)
// //         return user, err
// // }

// // func (as *authService) Getuser(ctx context.Context, id int) *models.User {
// //         user, _ := models.FindUser(ctx, as.db, id)
// //         return user
// // }

// NOTE: パスワードの文字列をハッシュ化する
func (as *authService) encryptPassword(password string) (string, error) <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(hash), nil</span>
}

// NOTE: パスワードの照合
func (as *authService) compareHashPassword(hashedPassword, requestPassword string) error <span class="cov8" title="1">{
        if err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(requestPassword)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (as *authService) uploadIdentification(bucket *storage.BucketHandle, path string, reader io.Reader) error <span class="cov8" title="1">{
        obj := bucket.Object(path)
        writer := obj.NewWriter(ctx)
        // NOTE: ファイルをCloud Storageにコピー
        if _, err := io.Copy(writer, reader); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // NOTE: Writerを閉じて完了
        <span class="cov8" title="1">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        models "app/models/generated"
        apis "app/openapi"
        "app/validator"
        "context"
        "database/sql"
        "fmt"
        "net/http"

        "github.com/volatiletech/null/v8"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type TodoService interface {
        CreateTodo(ctx context.Context, requestParams apis.PostTodosJSONRequestBody, userID int64) (statusCode int, err error)
        FetchTodosList(ctx context.Context, userID int64) (statusCode int, todosList *models.TodoSlice, err error)
        ShowTodo(ctx context.Context, id int64, userID int64) (statusCode int, todo *models.Todo)
        UpdateTodo(ctx context.Context, id int64, requestParams apis.PatchTodoJSONRequestBody, userID int64) (statusCode int, err error)
        DeleteTodo(ctx context.Context, id int64, userID int64) (statusCode int, err error)
}

type todoService struct {
        db *sql.DB
}

func NewTodoService(db *sql.DB) TodoService <span class="cov8" title="1">{
        return &amp;todoService{db}
}</span>

func (ts *todoService) CreateTodo(ctx context.Context, requestParams apis.PostTodosJSONRequestBody, userID int64) (statusCode int, err error) <span class="cov8" title="1">{
        // NOTE: バリデーションチェック
        validationErrors := validator.ValidateCreateTodo(requestParams)
        if validationErrors != nil </span><span class="cov8" title="1">{
                return int(http.StatusBadRequest), validationErrors
        }</span>
        <span class="cov8" title="1">fmt.Println("validationErrors", validationErrors)

        todo := &amp;models.Todo{}
        todo.Title = requestParams.Title
        todo.Content = null.String{String: requestParams.Content, Valid: true}
        todo.UserID = userID
        // NOTE: Create処理
        err = todo.Insert(ctx, ts.db, boil.Infer())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return int(http.StatusInternalServerError), err
        }</span>
        <span class="cov8" title="1">return int(http.StatusOK), nil</span>
}

func (ts *todoService) FetchTodosList(ctx context.Context, userID int64) (statusCode int, todosList *models.TodoSlice, err error) <span class="cov8" title="1">{
        todos, err := models.Todos(qm.Where("user_id = ?", userID)).All(ctx, ts.db)
        if err != nil </span><span class="cov0" title="0">{
                return int(http.StatusInternalServerError), &amp;models.TodoSlice{}, err
        }</span>

        <span class="cov8" title="1">return int(http.StatusOK), &amp;todos, nil</span>
}

func (ts *todoService) ShowTodo(ctx context.Context, id int64, userID int64) (statusCode int, todo *models.Todo) <span class="cov8" title="1">{
        todo, err := models.Todos(qm.Where("id = ? AND user_id = ?", id, userID)).One(ctx, ts.db)
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, &amp;models.Todo{}
        }</span>

        <span class="cov8" title="1">return http.StatusOK, todo</span>
}

func (ts *todoService) UpdateTodo(ctx context.Context, id int64, requestParams apis.PatchTodoJSONRequestBody, userID int64) (statusCode int, err error) <span class="cov8" title="1">{
        todo, err := models.Todos(qm.Where("id = ? AND user_id = ?", id, userID)).One(ctx, ts.db)
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, err
        }</span>

        // NOTE: バリデーションチェック
        <span class="cov8" title="1">validationErrors := validator.ValidateUpdateTodo(requestParams)
        if validationErrors != nil </span><span class="cov8" title="1">{
                return int(http.StatusBadRequest), validationErrors
        }</span>

        <span class="cov8" title="1">todo.Title = requestParams.Title
        todo.Content = null.String{String: requestParams.Content, Valid: true}

        // NOTE: Update処理
        _, updateError := todo.Update(ctx, ts.db, boil.Infer())
        if updateError != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, updateError
        }</span>
        <span class="cov8" title="1">return http.StatusOK, nil</span>
}

func (ts *todoService) DeleteTodo(ctx context.Context, id int64, userID int64) (statusCode int, err error) <span class="cov8" title="1">{
        todo, err := models.Todos(qm.Where("id = ? AND user_id = ?", id, userID)).One(ctx, ts.db)
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, err
        }</span>

        <span class="cov8" title="1">_, deleteError := todo.Delete(ctx, ts.db)
        if deleteError != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, deleteError
        }</span>
        <span class="cov8" title="1">return http.StatusOK, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "app/db"
        "context"
        "database/sql"

        "github.com/DATA-DOG/go-txdb"
        _ "github.com/go-sql-driver/mysql"
        "github.com/stretchr/testify/suite"
)

type WithDBSuite struct {
        suite.Suite
}

var DBCon *sql.DB
var ctx context.Context

// func (s *WithDBSuite) SetupSuite()                           {} // テストスイート実施前の処理
// func (s *WithDBSuite) TearDownSuite()                        {} // テストスイート終了後の処理
// func (s *WithDBSuite) SetupTest()                            {} // テストケース実施前の処理
// func (s *WithDBSuite) TearDownTest()                         {} // テストケース終了後の処理
// func (s *WithDBSuite) BeforeTest(suiteName, testName string) {} // テストケース実施前の処理
// func (s *WithDBSuite) AfterTest(suiteName, testName string)  {} // テストケース終了後の処理

func init() <span class="cov8" title="1">{
        txdb.Register("txdb-service", "mysql", db.GetDsn())
        ctx = context.Background()
}</span>

func (s *WithDBSuite) SetDBCon() <span class="cov8" title="1">{
        db, err := sql.Open("txdb-service", "connect")
        if err != nil </span><span class="cov0" title="0">{
                s.T().Fatalf("failed to initialize DB: %v", err)
        }</span>
        <span class="cov8" title="1">DBCon = db</span>
}

func (s *WithDBSuite) CloseDB() <span class="cov8" title="1">{
        DBCon.Close()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package factories

import (
        models "app/models/generated"
        "log"

        "github.com/Pallinder/go-randomdata"
        "github.com/bluele/factory-go/factory"
        "golang.org/x/crypto/bcrypt"
)

var UserFactory = factory.NewFactory(
        &amp;models.User{
                FirstName: randomdata.FirstName(randomdata.RandomGender),
                LastName: randomdata.LastName(),
                Email: randomdata.Email(),
                FrontIdentification: randomdata.StringSample(),
                BackIdentification: randomdata.StringSample(),
        },
).Attr("Password", func(args factory.Args) (interface{}, error) <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte("password"), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to generate hash %v", err)
        }</span>
        <span class="cov8" title="1">return string(hash), nil</span>
})
</pre>
		
		<pre class="file" id="file21" style="display: none">package utils

import "context"

type key string

const (
        ctxKey key = "UserID"
)

func NewContext(ctx context.Context, v int) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, ctxKey, v)
}</span>

func ContextValue(ctx context.Context) (int64, bool) <span class="cov8" title="1">{
        v, ok := ctx.Value(ctxKey).(int)
        return int64(v), ok
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package routers

import (
        "app/middlewares"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

func ApplyMiddlewares(e *echo.Echo) *echo.Echo <span class="cov8" title="1">{
        // NOTE: CORSの設定
        e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
                AllowOrigins: []string{"http://localhost:5173"},
                AllowMethods: []string{http.MethodGet, http.MethodPatch, http.MethodPost, http.MethodDelete},
                AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept, echo.HeaderAccessControlAllowHeaders, echo.HeaderXCSRFToken},
        }))

        // NOTE: CSRF対策
        csrfConfig := middleware.CSRFConfig{
                TokenLookup: "header:"+echo.HeaderXCSRFToken,
                CookieMaxAge: 3600,
        }
        e.Use(middleware.CSRFWithConfig(csrfConfig))

        // NOTE: CSRF トークンを context.Context に埋め込むミドルウェアを適用
        //            : StrictHandlerだとecho.Contextがhandler側で使えずのため
        e.Use(middlewares.CSRFContextMiddleware)

        return e
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package utils

import (
        "fmt"

        "github.com/go-playground/validator/v10"
)

func CoordinateValidationErrors(validationErrors error) map[string][]string <span class="cov0" title="0">{
        errors := make(map[string][]string)

        for _, err := range validationErrors.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                field := err.Field()

                errors[field] = []string{}

                switch err.ActualTag() </span>{
                case "required":<span class="cov0" title="0">
                        errors[field] = append(errors[field], fmt.Sprintf("%sは必須です", err.Field()))</span>
                }
        }

        <span class="cov0" title="0">return errors</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package validator

import (
        apis "app/openapi"

        validation "github.com/go-ozzo/ozzo-validation/v4"
)

func ValidateCreateTodo(input apis.PostTodosJSONRequestBody) error <span class="cov8" title="1">{
        return validation.ValidateStruct(&amp;input,
                validation.Field(
                        &amp;input.Title,
                        validation.Required.Error("タイトルは必須入力です。"),
                        validation.RuneLength(1, 50).Error("タイトルは1 ~ 50文字での入力をお願いします。"),
                ),
        )
}</span>

func ValidateUpdateTodo(input  apis.PatchTodoJSONRequestBody) error <span class="cov8" title="1">{
        return validation.ValidateStruct(&amp;input,
                validation.Field(
                        &amp;input.Title,
                        validation.Required.Error("タイトルは必須入力です。"),
                        validation.RuneLength(1, 50).Error("タイトルは1 ~ 50文字での入力をお願いします。"),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package validator

import (
        apis "app/openapi"
        "fmt"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/go-ozzo/ozzo-validation/v4/is"
        "golang.org/x/exp/slices"

        "github.com/gabriel-vasile/mimetype"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

var allowedMIMEType = []string{"image/webp", "image/png", "image/jpeg"}

func ValidateSignUp(input *apis.PostAuthValidateSignUpMultipartRequestBody) error <span class="cov8" title="1">{
        return validation.ValidateStruct(input,
                validation.Field(
                        &amp;input.FirstName,
                        validation.Required.Error("名は必須入力です。"),
                        validation.RuneLength(1, 20).Error("名は1 ~ 20文字での入力をお願いします。"),
                ),
                validation.Field(
                        &amp;input.LastName,
                        validation.Required.Error("姓は必須入力です。"),
                        validation.RuneLength(1, 20).Error("姓は1 ~ 20文字での入力をお願いします。"),
                ),
                validation.Field(
                        &amp;input.Email,
                        validation.Required.Error("Emailは必須入力です。"),
                        is.Email.Error("Emailの形式での入力をお願いします。"),
                ),
                validation.Field(
                        &amp;input.Password,
                        validation.Required.Error("パスワードは必須入力です。"),
                        validation.Length(8, 24).Error("パスワードは8 ~ 24文字での入力をお願いします。"),
                ),
                validation.Field(
                        &amp;input.FrontIdentification,
                        validation.By(isValidFileMimeType("身分証明書(表)")),
                ),
                validation.Field(
                        &amp;input.BackIdentification,
                        validation.By(isValidFileMimeType("身分証明書(裏)")),
                ),
        )
}</span>

func isValidFileMimeType(field string) validation.RuleFunc <span class="cov8" title="1">{
        return func(value interface{}) error </span><span class="cov8" title="1">{
                fileInput, ok := value.(*openapi_types.File)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("%sが正しい形式ではありません", field)
                }</span>
                <span class="cov8" title="1">if fileInput == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                
                <span class="cov8" title="1">reader, err := fileInput.Reader()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%sのリーダーを開く際にエラーが発生しました: %v", field, err)
                }</span>

                <span class="cov8" title="1">mtype, err := mimetype.DetectReader(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%sのMIMEタイプを判別できません: %v", field, err)
                }</span>

                <span class="cov8" title="1">if isValid := slices.Contains(allowedMIMEType, mtype.String()); !isValid </span><span class="cov8" title="1">{
                        return fmt.Errorf("%sの拡張子はwebp, png, jpegのいずれかでお願いします。", field)
                }</span>
                <span class="cov8" title="1">return nil</span>
    }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
